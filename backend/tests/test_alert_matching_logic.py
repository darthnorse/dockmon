"""
Tests for alert matching logic with container patterns and host IDs
Would have caught issues with alert detection for specific hosts
"""

import pytest
from unittest.mock import MagicMock, AsyncMock
import re


class TestAlertMatchingLogic:
    """Test that alerts correctly match containers based on patterns and hosts"""

    @pytest.mark.asyncio
    async def test_single_container_pattern_matching(self):
        """Test matching a single container by exact name"""
        from notifications import NotificationService, AlertEvent
        from database import AlertRuleDB

        mock_db = MagicMock()

        # Rule for a specific container
        mock_rule = MagicMock(spec=AlertRuleDB)
        mock_rule.id = "rule-1"
        mock_rule.container_pattern = "web-app"
        mock_rule.host_id = None
        mock_rule.trigger_states = ["exited"]
        mock_rule.trigger_events = None
        mock_rule.notification_channels = [1]
        mock_rule.enabled = True

        mock_db.get_alert_rules.return_value = [mock_rule]
        service = NotificationService(mock_db)

        # Matching event
        event = AlertEvent(
            host_id="host-1",
            container_id="container-1",
            container_name="web-app",
            old_state="running",
            new_state="exited",
            triggered_by="monitor"
        )

        matching_rules = await service._get_matching_rules(event)
        assert len(matching_rules) == 1

        # Non-matching event (different container)
        event2 = AlertEvent(
            host_id="host-1",
            container_id="container-2",
            container_name="db-app",
            old_state="running",
            new_state="exited",
            triggered_by="monitor"
        )

        matching_rules2 = await service._get_matching_rules(event2)
        assert len(matching_rules2) == 0

    @pytest.mark.asyncio
    async def test_multi_container_pattern_matching(self):
        """Test matching multiple containers with OR pattern"""
        from notifications import NotificationService, AlertEvent
        from database import AlertRuleDB

        mock_db = MagicMock()

        # Rule with multiple containers (as generated by frontend)
        mock_rule = MagicMock(spec=AlertRuleDB)
        mock_rule.id = "rule-1"
        mock_rule.container_pattern = "^(web-1|web-2|web-3)$"
        mock_rule.host_id = None
        mock_rule.trigger_states = ["dead"]
        mock_rule.trigger_events = None
        mock_rule.notification_channels = [1]
        mock_rule.enabled = True

        mock_db.get_alert_rules.return_value = [mock_rule]
        service = NotificationService(mock_db)

        # Test each container in the pattern
        for container_name in ["web-1", "web-2", "web-3"]:
            event = AlertEvent(
                host_id="host-1",
                container_id=f"container-{container_name}",
                container_name=container_name,
                old_state="running",
                new_state="dead",
                triggered_by="monitor"
            )

            matching_rules = await service._get_matching_rules(event)
            assert len(matching_rules) == 1, f"Container {container_name} should match"

        # Test container NOT in pattern
        event = AlertEvent(
            host_id="host-1",
            container_id="container-4",
            container_name="web-4",
            old_state="running",
            new_state="dead",
            triggered_by="monitor"
        )

        matching_rules = await service._get_matching_rules(event)
        assert len(matching_rules) == 0

    @pytest.mark.asyncio
    async def test_host_specific_matching(self):
        """Test that host_id properly filters rules"""
        from notifications import NotificationService, AlertEvent
        from database import AlertRuleDB

        mock_db = MagicMock()

        # Rule specific to host-1
        rule1 = MagicMock(spec=AlertRuleDB)
        rule1.id = "rule-1"
        rule1.container_pattern = "web-app"
        rule1.host_id = "host-1"  # Specific host
        rule1.trigger_states = ["exited"]
        rule1.trigger_events = None
        rule1.notification_channels = [1]
        rule1.enabled = True

        # Rule for all hosts
        rule2 = MagicMock(spec=AlertRuleDB)
        rule2.id = "rule-2"
        rule2.container_pattern = "web-app"
        rule2.host_id = None  # All hosts
        rule2.trigger_states = ["exited"]
        rule2.trigger_events = None
        rule2.notification_channels = [1]
        rule2.enabled = True

        mock_db.get_alert_rules.return_value = [rule1, rule2]
        service = NotificationService(mock_db)

        # Event from host-1
        event1 = AlertEvent(
            host_id="host-1",
            container_id="container-1",
            container_name="web-app",
            old_state="running",
            new_state="exited",
            triggered_by="monitor"
        )

        matching_rules = await service._get_matching_rules(event1)
        # Both rules should match (host-specific and all-hosts)
        assert len(matching_rules) == 2
        assert set(r.id for r in matching_rules) == {"rule-1", "rule-2"}

        # Event from host-2
        event2 = AlertEvent(
            host_id="host-2",
            container_id="container-2",
            container_name="web-app",
            old_state="running",
            new_state="exited",
            triggered_by="monitor"
        )

        matching_rules = await service._get_matching_rules(event2)
        # Only all-hosts rule should match
        assert len(matching_rules) == 1
        assert matching_rules[0].id == "rule-2"

    @pytest.mark.asyncio
    async def test_wildcard_pattern_matching(self):
        """Test wildcard patterns like .* and web-.*"""
        from notifications import NotificationService, AlertEvent
        from database import AlertRuleDB

        mock_db = MagicMock()

        # All containers pattern
        rule1 = MagicMock(spec=AlertRuleDB)
        rule1.id = "rule-all"
        rule1.container_pattern = ".*"
        rule1.host_id = None
        rule1.trigger_states = ["exited"]
        rule1.trigger_events = None
        rule1.notification_channels = [1]
        rule1.enabled = True

        # Prefix pattern
        rule2 = MagicMock(spec=AlertRuleDB)
        rule2.id = "rule-web"
        rule2.container_pattern = "web-.*"
        rule2.host_id = None
        rule2.trigger_states = ["exited"]
        rule2.trigger_events = None
        rule2.notification_channels = [1]
        rule2.enabled = True

        mock_db.get_alert_rules.return_value = [rule1, rule2]
        service = NotificationService(mock_db)

        # Test web container
        event = AlertEvent(
            host_id="host-1",
            container_id="container-1",
            container_name="web-frontend",
            old_state="running",
            new_state="exited",
            triggered_by="monitor"
        )

        matching_rules = await service._get_matching_rules(event)
        # Both rules should match
        assert len(matching_rules) == 2

        # Test non-web container
        event2 = AlertEvent(
            host_id="host-1",
            container_id="container-2",
            container_name="database",
            old_state="running",
            new_state="exited",
            triggered_by="monitor"
        )

        matching_rules = await service._get_matching_rules(event2)
        # Only all-containers rule should match
        assert len(matching_rules) == 1
        assert matching_rules[0].id == "rule-all"

    def test_regex_pattern_validation(self):
        """Test that regex patterns are properly validated"""
        patterns_and_containers = [
            ("web-app", "web-app", True),           # Exact match
            ("web-.*", "web-app", True),            # Prefix match
            ("web-.*", "web-", True),               # Prefix boundary
            ("web-.*", "database", False),          # No match
            (".*", "anything", True),               # Match all
            ("^web$", "web", True),                 # Anchored match
            ("^web$", "web-app", False),            # Anchored no match
            ("^(app1|app2)$", "app1", True),        # Multi-container
            ("^(app1|app2)$", "app3", False),       # Multi-container no match
        ]

        for pattern, container, should_match in patterns_and_containers:
            result = bool(re.search(pattern, container))
            assert result == should_match, f"Pattern '{pattern}' vs '{container}' failed"

    @pytest.mark.asyncio
    async def test_escaped_special_characters_in_pattern(self):
        """Test patterns with escaped special regex characters"""
        from notifications import NotificationService, AlertEvent
        from database import AlertRuleDB

        mock_db = MagicMock()

        # Pattern with escaped dots (common in container names)
        mock_rule = MagicMock(spec=AlertRuleDB)
        mock_rule.id = "rule-1"
        mock_rule.container_pattern = "^(my\\.app|test\\.service)$"
        mock_rule.host_id = None
        mock_rule.trigger_states = ["exited"]
        mock_rule.trigger_events = None
        mock_rule.notification_channels = [1]
        mock_rule.enabled = True

        mock_db.get_alert_rules.return_value = [mock_rule]
        service = NotificationService(mock_db)

        # Should match container with dot
        event = AlertEvent(
            host_id="host-1",
            container_id="container-1",
            container_name="my.app",
            old_state="running",
            new_state="exited",
            triggered_by="monitor"
        )

        matching_rules = await service._get_matching_rules(event)
        assert len(matching_rules) == 1

    @pytest.mark.asyncio
    async def test_invalid_regex_handling(self):
        """Test that invalid regex patterns don't crash the system"""
        from notifications import NotificationService, AlertEvent
        from database import AlertRuleDB

        mock_db = MagicMock()

        # Rule with invalid regex
        mock_rule = MagicMock(spec=AlertRuleDB)
        mock_rule.id = "rule-bad"
        mock_rule.container_pattern = "[invalid("  # Invalid regex
        mock_rule.host_id = None
        mock_rule.trigger_states = ["exited"]
        mock_rule.trigger_events = None
        mock_rule.notification_channels = [1]
        mock_rule.enabled = True

        mock_db.get_alert_rules.return_value = [mock_rule]
        service = NotificationService(mock_db)

        event = AlertEvent(
            host_id="host-1",
            container_id="container-1",
            container_name="test",
            old_state="running",
            new_state="exited",
            triggered_by="monitor"
        )

        # Should handle gracefully without crashing
        matching_rules = await service._get_matching_rules(event)
        assert len(matching_rules) == 0  # Invalid pattern won't match

    @pytest.mark.parametrize("pattern,container,host_rule,host_event,should_match", [
        # Single container, no host restriction
        ("web-app", "web-app", None, "host-1", True),
        ("web-app", "web-app", None, "host-2", True),

        # Single container, host restriction
        ("web-app", "web-app", "host-1", "host-1", True),
        ("web-app", "web-app", "host-1", "host-2", False),

        # Multi-container pattern, no host restriction
        ("^(app1|app2)$", "app1", None, "host-1", True),
        ("^(app1|app2)$", "app2", None, "host-2", True),
        ("^(app1|app2)$", "app3", None, "host-1", False),

        # Multi-container pattern, host restriction
        ("^(app1|app2)$", "app1", "host-1", "host-1", True),
        ("^(app1|app2)$", "app1", "host-1", "host-2", False),

        # Wildcard pattern
        (".*", "any-container", None, "host-1", True),
        ("web-.*", "web-frontend", None, "host-1", True),
        ("web-.*", "database", None, "host-1", False),

        # Edge cases
        ("", "container", None, "host-1", False),  # Empty pattern
        ("container", "", None, "host-1", False),  # Empty container name
    ])
    @pytest.mark.asyncio
    async def test_comprehensive_matching_scenarios(
        self, pattern, container, host_rule, host_event, should_match
    ):
        """Test comprehensive matching scenarios"""
        from notifications import NotificationService, AlertEvent
        from database import AlertRuleDB

        mock_db = MagicMock()

        mock_rule = MagicMock(spec=AlertRuleDB)
        mock_rule.id = "test-rule"
        mock_rule.container_pattern = pattern
        mock_rule.host_id = host_rule
        mock_rule.trigger_states = ["exited"]
        mock_rule.trigger_events = None
        mock_rule.notification_channels = [1]
        mock_rule.enabled = True

        mock_db.get_alert_rules.return_value = [mock_rule]
        service = NotificationService(mock_db)

        event = AlertEvent(
            host_id=host_event,
            container_id="container-id",
            container_name=container,
            old_state="running",
            new_state="exited",
            triggered_by="monitor"
        )

        matching_rules = await service._get_matching_rules(event)

        if should_match:
            assert len(matching_rules) == 1
            assert matching_rules[0].id == "test-rule"
        else:
            assert len(matching_rules) == 0