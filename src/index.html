<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DockMon</title>
    <link rel="icon" type="image/x-icon" href="/images/favicon.ico">
    <!-- GridStack.js CSS -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gridstack@10.0.1/dist/gridstack.min.css">
    <style>
        :root {
            /* Modern color scheme */
            --primary: #0084F4;
            --primary-dark: #0066CC;
            --primary-light: #E8F4FD;
            --success: #00C48C;
            --warning: #FFA26B;
            --danger: #FF647C;
            --dark: #1A1D29;
            --dark-secondary: #252837;
            --dark-tertiary: #2D3142;
            --text-primary: #FFFFFF;
            --text-secondary: #A0A3BD;
            --text-tertiary: #6E7191;
            --border: #353849;
            --surface: #1E2139;
            --surface-light: #262A41;
            --background: #161821;
            
            /* Spacing */
            --spacing-xs: 4px;
            --spacing-sm: 8px;
            --spacing-md: 16px;
            --spacing-lg: 24px;
            --spacing-xl: 32px;
            --spacing-2xl: 48px;
            
            /* Transitions */
            --transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', sans-serif;
            background: var(--background);
            color: var(--text-primary);
            line-height: 1.6;
            overflow-x: hidden;
        }

        /* Layout */
        .app-layout {
            display: flex;
            height: 100vh;
        }

        /* Sidebar */
        .sidebar {
            width: 260px;
            background: var(--dark);
            border-right: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            transition: var(--transition);
            z-index: 100;
        }

        .sidebar-header {
            padding: var(--spacing-lg);
            border-bottom: 1px solid var(--border);
            display: flex;
            align-items: center;
            gap: var(--spacing-md);
        }

        .logo {
            width: 36px;
            height: 36px;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .logo img {
            width: 32px;
            height: 32px;
            border-radius: 6px;
        }

        .logo-text {
            font-size: 18px;
            font-weight: 600;
            color: var(--text-primary);
        }

        .sidebar-nav {
            flex: 1;
            padding: var(--spacing-lg) 0;
            overflow-y: auto;
        }

        .nav-section {
            margin-bottom: var(--spacing-xl);
        }

        .nav-section-title {
            padding: 0 var(--spacing-lg);
            margin-bottom: var(--spacing-sm);
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: var(--text-tertiary);
        }

        .nav-item {
            display: flex;
            align-items: center;
            gap: var(--spacing-md);
            padding: var(--spacing-md) var(--spacing-lg);
            color: var(--text-secondary);
            text-decoration: none;
            transition: var(--transition);
            cursor: pointer;
            border: none;
            background: none;
            width: 100%;
            font-size: 14px;
            position: relative;
        }

        .nav-item::before {
            content: '';
            position: absolute;
            left: 0;
            top: 0;
            bottom: 0;
            width: 3px;
            background: var(--primary);
            opacity: 0;
            transition: var(--transition);
        }

        .nav-item:hover {
            background: var(--surface);
            color: var(--text-primary);
        }

        .nav-item.active {
            background: var(--surface);
            color: var(--primary);
        }

        .nav-item.active::before {
            opacity: 1;
        }

        .nav-icon {
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
        }

        .nav-badge {
            margin-left: auto;
            padding: 2px 8px;
            background: var(--primary);
            color: white;
            border-radius: 10px;
            font-size: 11px;
            font-weight: 600;
        }

        /* Main Content */
        .main-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            background: var(--background);
            overflow: hidden;
        }

        /* Top Bar */
        .topbar {
            height: 60px;
            background: var(--dark);
            border-bottom: 1px solid var(--border);
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 var(--spacing-xl);
        }

        .topbar-title {
            font-size: 20px;
            font-weight: 600;
            color: var(--text-primary);
        }

        .topbar-actions {
            display: flex;
            align-items: center;
            gap: var(--spacing-md);
        }

        /* Content Area */
        .content {
            flex: 1;
            padding: var(--spacing-xl);
            overflow-y: auto;
            overflow-x: hidden;
        }

        /* Cards */
        .card {
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: var(--spacing-lg);
            margin-bottom: var(--spacing-lg);
            transition: var(--transition);
        }

        .card:hover {
            border-color: var(--primary);
            box-shadow: 0 4px 12px rgba(0, 132, 244, 0.1);
        }

        .card-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: var(--spacing-lg);
            padding-bottom: var(--spacing-md);
            border-bottom: 1px solid var(--border);
        }

        .card-title {
            font-size: 16px;
            font-weight: 600;
            color: var(--text-primary);
            display: flex;
            align-items: center;
            gap: var(--spacing-sm);
        }

        /* GridStack Overrides */
        .grid-stack {
            margin-bottom: var(--spacing-xl);
        }

        .grid-stack-item-content {
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: 12px;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            height: 100%;
        }

        .grid-stack-item.ui-draggable-dragging .grid-stack-item-content {
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
            opacity: 0.8;
        }

        .grid-stack-item.ui-resizable-resizing .grid-stack-item-content {
            opacity: 0.7;
        }

        .widget-header {
            padding: var(--spacing-md) var(--spacing-lg);
            border-bottom: 1px solid var(--border);
            display: flex;
            align-items: center;
            justify-content: space-between;
            background: var(--dark-secondary);
            cursor: move;
        }

        .widget-title {
            font-size: 14px;
            font-weight: 600;
            color: var(--text-primary);
            display: flex;
            align-items: center;
            gap: var(--spacing-sm);
        }

        .widget-actions {
            display: flex;
            gap: var(--spacing-xs);
        }

        .widget-action {
            width: 24px;
            height: 24px;
            border-radius: 6px;
            background: transparent;
            border: none;
            color: var(--text-secondary);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: var(--transition);
        }

        .widget-action:hover {
            background: var(--surface-light);
            color: var(--text-primary);
        }

        .widget-action.lock-btn.locked {
            color: var(--warning);
        }

        .widget-body {
            flex: 1;
            padding: var(--spacing-lg);
            overflow: auto;
        }

        /* Stats Grid */
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: var(--spacing-md);
            height: 100%;
        }

        /* Responsive adjustments */
        .grid-stack-item[gs-w="12"] .stats-grid {
            grid-template-columns: repeat(4, 1fr);
        }

        .grid-stack-item[gs-w="8"] .stats-grid,
        .grid-stack-item[gs-w="9"] .stats-grid,
        .grid-stack-item[gs-w="10"] .stats-grid,
        .grid-stack-item[gs-w="11"] .stats-grid {
            grid-template-columns: repeat(2, 1fr);
        }

        .grid-stack-item[gs-w="4"] .stats-grid,
        .grid-stack-item[gs-w="5"] .stats-grid,
        .grid-stack-item[gs-w="6"] .stats-grid,
        .grid-stack-item[gs-w="7"] .stats-grid {
            grid-template-columns: repeat(2, 1fr);
        }

        .grid-stack-item[gs-w="3"] .stats-grid,
        .grid-stack-item[gs-w="2"] .stats-grid {
            grid-template-columns: 1fr;
        }

        /* Widget-specific styles */
        .widget-hosts .hosts-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
            gap: var(--spacing-md);
        }

        .grid-stack-item[gs-w="3"] .widget-hosts .hosts-grid,
        .grid-stack-item[gs-w="4"] .widget-hosts .hosts-grid,
        .grid-stack-item[gs-w="5"] .widget-hosts .hosts-grid,
        .grid-stack-item[gs-w="6"] .widget-hosts .hosts-grid {
            grid-template-columns: 1fr;
        }

        .grid-stack-item[gs-w="7"] .widget-hosts .hosts-grid,
        .grid-stack-item[gs-w="8"] .widget-hosts .hosts-grid,
        .grid-stack-item[gs-w="9"] .widget-hosts .hosts-grid,
        .grid-stack-item[gs-w="10"] .widget-hosts .hosts-grid,
        .grid-stack-item[gs-w="11"] .widget-hosts .hosts-grid,
        .grid-stack-item[gs-w="12"] .widget-hosts .hosts-grid {
            grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
        }

        /* Compact layout for smaller widgets */
        .grid-stack-item[gs-h="2"] .widget-hosts .container-list {
            max-height: 60px;
            overflow-y: auto;
        }

        .grid-stack-item[gs-h="3"] .widget-hosts .container-list {
            max-height: 90px;
            overflow-y: auto;
        }

        .grid-stack-item[gs-h="4"] .widget-hosts .container-list {
            max-height: 130px;
            overflow-y: auto;
        }

        /* Make host cards more compact in small widgets */
        .grid-stack-item[gs-w="3"] .host-card,
        .grid-stack-item[gs-w="4"] .host-card {
            padding: var(--spacing-sm);
        }

        .grid-stack-item[gs-w="3"] .host-header,
        .grid-stack-item[gs-w="4"] .host-header {
            margin-bottom: var(--spacing-sm);
        }

        .grid-stack-item[gs-w="3"] .container-item,
        .grid-stack-item[gs-w="4"] .container-item {
            padding: 4px 0;
        }

        /* Ensure stats grid is always visible */
        .grid-stack-item[gs-h="3"] .stats-grid {
            height: 100%;
            align-content: center;
        }

        .grid-stack-item[gs-h="4"] .stats-grid {
            height: 100%;
            align-content: space-evenly;
        }

        /* Host card improvements */
        .host-card {
            background: var(--dark-secondary);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: var(--spacing-md);
            transition: var(--transition);
        }

        .host-card:hover {
            border-color: var(--primary);
            background: var(--surface);
        }

        .stat-card {
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: var(--spacing-lg);
            position: relative;
            overflow: hidden;
            transition: var(--transition);
        }

        .stat-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }

        .stat-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 3px;
            background: linear-gradient(90deg, var(--primary), var(--primary-dark));
        }

        .stat-icon {
            width: 40px;
            height: 40px;
            background: var(--primary);
            background: linear-gradient(135deg, var(--primary), var(--primary-dark));
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            margin-bottom: var(--spacing-md);
        }

        .stat-value {
            font-size: 28px;
            font-weight: 700;
            color: var(--text-primary);
            margin-bottom: var(--spacing-xs);
        }

        .stat-label {
            font-size: 12px;
            color: var(--text-secondary); /* Made more visible */
            text-transform: uppercase;
            letter-spacing: 0.5px;
            font-weight: 500;
        }

        .stat-change {
            position: absolute;
            top: var(--spacing-md);
            right: var(--spacing-md);
            padding: 4px 8px;
            background: var(--success);
            color: white;
            border-radius: 4px;
            font-size: 12px;
            font-weight: 600;
        }

        .stat-change.negative {
            background: var(--danger);
        }

        /* Buttons */
        .btn {
            padding: 10px 20px;
            border-radius: 6px;
            border: none;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: var(--transition);
            display: inline-flex;
            align-items: center;
            gap: var(--spacing-sm);
        }

        .btn-primary {
            background: var(--primary);
            color: white;
        }

        .btn-primary:hover {
            background: var(--primary-dark);
            transform: translateY(-1px);
        }

        .btn-secondary {
            background: var(--surface-light);
            color: var(--text-primary);
            border: 1px solid var(--border);
        }

        .btn-secondary:hover {
            background: var(--dark-tertiary);
            border-color: var(--primary);
        }

        .btn-danger {
            background: var(--danger);
            color: white;
        }

        .btn-danger:hover {
            background: #d32f2f;
            transform: translateY(-1px);
        }

        .btn-success {
            background: var(--success);
            color: white;
        }

        .btn-danger {
            background: var(--danger);
            color: white;
        }

        .btn-icon {
            padding: 8px;
            border-radius: 6px;
            background: var(--surface-light);
            border: 1px solid var(--border);
            cursor: pointer;
            transition: var(--transition);
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .btn-icon:hover {
            background: var(--dark-tertiary);
            border-color: var(--primary);
        }

        /* Host Grid */
        .hosts-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(400px, 1fr));
            gap: var(--spacing-lg);
        }

        .host-card {
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: 8px;
            overflow: hidden;
            transition: var(--transition);
        }

        .host-card:hover {
            border-color: var(--primary);
            box-shadow: 0 4px 12px rgba(0, 132, 244, 0.1);
        }

        .host-header {
            padding: var(--spacing-md) var(--spacing-lg);
            background: var(--surface-light);
            border-bottom: 1px solid var(--border);
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .host-name {
            font-weight: 600;
            color: var(--text-primary);
            display: flex;
            align-items: center;
            gap: var(--spacing-sm);
        }

        .host-status {
            padding: 4px 12px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: 600;
            text-transform: uppercase;
        }

        .status-online {
            background: rgba(0, 196, 140, 0.1);
            color: var(--success);
        }

        .status-offline {
            background: rgba(255, 100, 124, 0.1);
            color: var(--danger);
        }

        /* Container List */
        .container-list {
            padding: var(--spacing-md);
        }

        .container-item {
            padding: var(--spacing-md);
            background: var(--dark);
            border-radius: 6px;
            margin-bottom: var(--spacing-sm);
            display: flex;
            align-items: center;
            justify-content: space-between;
            transition: var(--transition);
            cursor: pointer;
        }

        .container-item:hover {
            background: var(--surface-light);
            transform: translateX(4px);
        }

        .container-item:last-child {
            margin-bottom: 0;
        }

        .container-info {
            display: flex;
            align-items: center;
            gap: var(--spacing-md);
            flex: 1;
        }

        .container-icon {
            width: 32px;
            height: 32px;
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
        }

        .container-running {
            background: rgba(0, 196, 140, 0.2);
            color: var(--success);
        }

        .container-stopped {
            background: rgba(255, 100, 124, 0.2);
            color: var(--danger);
        }

        .container-paused {
            background: rgba(255, 162, 107, 0.2);
            color: var(--warning);
        }

        .container-details {
            flex: 1;
        }

        .container-name {
            font-size: 14px;
            font-weight: 500;
            color: var(--text-primary);
            margin-bottom: 2px;
        }

        .container-id {
            font-size: 12px;
            color: var(--text-tertiary);
            font-family: 'Monaco', 'Courier New', monospace;
        }

        .container-actions {
            display: flex;
            align-items: center;
            gap: var(--spacing-md);
        }

        .container-state {
            padding: 4px 10px;
            border-radius: 4px;
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        /* Auto Restart Toggle */
        .auto-restart-toggle {
            display: flex;
            align-items: center;
            gap: var(--spacing-sm);
            padding: 6px 12px;
            background: var(--surface-light);
            border: 1px solid var(--border);
            border-radius: 6px;
            font-size: 12px;
            transition: var(--transition);
        }

        .auto-restart-toggle.enabled {
            background: rgba(0, 132, 244, 0.1);
            border-color: var(--primary);
            color: var(--primary);
        }

        .toggle-switch {
            position: relative;
            width: 36px;
            height: 20px;
            background: var(--dark-tertiary);
            border-radius: 20px;
            cursor: pointer;
            transition: var(--transition);
        }

        .toggle-switch.active {
            background: var(--primary);
        }

        .toggle-switch::after {
            content: '';
            position: absolute;
            width: 16px;
            height: 16px;
            background: white;
            border-radius: 50%;
            top: 2px;
            left: 2px;
            transition: transform 0.2s ease;
        }

        .toggle-switch.active::after {
            transform: translateX(16px);
        }

        /* Modal */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(5px);
            z-index: 1000;
        }

        .modal.active {
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .modal-content {
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: var(--spacing-xl);
            max-width: 600px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
            animation: modalSlideIn 0.3s ease;
        }

        @keyframes modalSlideIn {
            from {
                opacity: 0;
                transform: translateY(-30px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: var(--spacing-lg);
            padding-bottom: var(--spacing-md);
            border-bottom: 1px solid var(--border);
        }

        .modal-title {
            font-size: 20px;
            font-weight: 600;
            color: var(--text-primary);
        }

        .modal-close {
            width: 32px;
            height: 32px;
            border-radius: 6px;
            border: 1px solid var(--border);
            background: var(--surface-light);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: var(--transition);
        }

        .modal-close:hover {
            background: var(--danger);
            border-color: var(--danger);
            transform: rotate(90deg);
        }

        /* Tab styles */
        .tab-content {
            animation: fadeIn 0.3s ease;
        }

        .tab-content pre {
            margin: 0;
            white-space: pre-wrap;
            word-break: break-all;
        }

        #container-logs, #exec-output {
            scrollbar-width: thin;
            scrollbar-color: var(--border) var(--dark);
        }

        #container-logs::-webkit-scrollbar,
        #exec-output::-webkit-scrollbar {
            width: 8px;
        }

        #container-logs::-webkit-scrollbar-track,
        #exec-output::-webkit-scrollbar-track {
            background: var(--dark);
        }

        #container-logs::-webkit-scrollbar-thumb,
        #exec-output::-webkit-scrollbar-thumb {
            background: var(--border);
            border-radius: 4px;
        }

        #container-logs::-webkit-scrollbar-thumb:hover,
        #exec-output::-webkit-scrollbar-thumb:hover {
            background: var(--primary);
        }

        /* Form Elements */
        .form-group {
            margin-bottom: var(--spacing-lg);
        }

        .form-label {
            display: block;
            margin-bottom: var(--spacing-sm);
            font-size: 14px;
            font-weight: 500;
            color: var(--text-secondary);
        }

        .form-input {
            width: 100%;
            padding: 10px 14px;
            background: var(--dark);
            border: 1px solid var(--border);
            border-radius: 6px;
            color: var(--text-primary);
            font-size: 14px;
            transition: var(--transition);
        }

        .form-input:focus {
            outline: none;
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(0, 132, 244, 0.1);
        }

        .checkbox-group {
            display: flex;
            flex-wrap: wrap;
            gap: var(--spacing-md);
            padding: var(--spacing-md);
            background: var(--dark);
            border-radius: 6px;
        }

        .checkbox-item {
            display: flex;
            align-items: center;
            gap: var(--spacing-sm);
            color: var(--text-secondary);
        }

        .checkbox-item input[type="checkbox"] {
            width: 18px;
            height: 18px;
            cursor: pointer;
        }

        /* Settings Section */
        .settings-section {
            background: var(--dark);
            padding: var(--spacing-lg);
            border-radius: 8px;
            margin-bottom: var(--spacing-lg);
        }

        .settings-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: var(--spacing-md) 0;
            border-bottom: 1px solid var(--border);
        }

        .settings-row:last-child {
            border-bottom: none;
        }

        .settings-label {
            display: flex;
            flex-direction: column;
            gap: var(--spacing-xs);
        }

        .settings-title {
            font-weight: 500;
            color: var(--text-primary);
        }

        .settings-description {
            font-size: 12px;
            color: var(--text-tertiary);
        }

        .settings-value {
            display: flex;
            align-items: center;
            gap: var(--spacing-md);
        }

        .number-input {
            width: 80px;
            padding: 8px 12px;
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: 6px;
            color: var(--text-primary);
            text-align: center;
            font-size: 14px;
            font-weight: 500;
            transition: var(--transition);
        }

        .number-input:focus {
            outline: none;
            border-color: var(--primary);
        }

        /* Alert Rules */
        .alert-rule-card {
            background: var(--dark);
            padding: var(--spacing-md);
            border-radius: 8px;
            margin-bottom: var(--spacing-md);
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: var(--transition);
        }

        .alert-rule-card:hover {
            background: var(--surface-light);
        }

        .alert-rule-info {
            flex: 1;
        }

        .alert-rule-title {
            font-weight: 500;
            color: var(--text-primary);
            margin-bottom: var(--spacing-xs);
        }

        .alert-rule-details {
            font-size: 13px;
            color: var(--text-tertiary);
        }

        .alert-channels {
            display: flex;
            gap: var(--spacing-sm);
            margin-top: var(--spacing-sm);
        }

        .alert-rule-actions {
            display: flex;
            gap: var(--spacing-xs);
        }

        .channel-badge {
            padding: 2px 8px;
            border-radius: 4px;
            font-size: 11px;
            font-weight: 600;
        }

        .channel-telegram {
            background: rgba(0, 136, 204, 0.2);
            color: #0088cc;
        }

        .channel-discord {
            background: rgba(88, 101, 242, 0.2);
            color: #5865F2;
        }

        .channel-pushover {
            background: rgba(79, 195, 247, 0.2);
            color: #4FC3F7;
        }

        /* Toast */
        .toast {
            position: fixed;
            bottom: var(--spacing-xl);
            right: var(--spacing-xl);
            background: var(--surface-light);
            border: 1px solid var(--border);
            color: var(--text-primary);
            padding: var(--spacing-md) var(--spacing-lg);
            border-radius: 6px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            z-index: 2000;
            display: none;
            animation: toastSlideIn 0.3s ease;
        }

        .toast.show {
            display: block;
        }

        @keyframes toastSlideIn {
            from {
                opacity: 0;
                transform: translateX(100px);
            }
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }

        /* Responsive */
        @media (max-width: 768px) {
            .sidebar {
                width: 60px;
            }

            .sidebar-header .logo-text,
            .nav-item span:not(.nav-icon),
            .nav-badge,
            .nav-section-title {
                display: none;
            }

            .hosts-grid {
                grid-template-columns: 1fr;
            }

            .stats-grid {
                grid-template-columns: 1fr;
            }
        }

        /* Page Sections */
        .page-section {
            display: none;
        }

        .page-section.active {
            display: block;
            animation: fadeIn 0.3s ease;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        /* Mobile Menu Toggle */
        .menu-toggle {
            display: none;
            padding: 8px;
            background: var(--surface-light);
            border: 1px solid var(--border);
            border-radius: 6px;
            cursor: pointer;
        }

        @media (max-width: 768px) {
            .menu-toggle {
                display: flex;
            }
        }
    </style>
</head>
<body>
    <div class="app-layout">
        <!-- Sidebar -->
        <aside class="sidebar">
            <div class="sidebar-header">
                <div class="logo">
                    <img src="/images/logo.png" alt="DockMon Logo">
                </div>
                <div class="logo-text">DockMon</div>
            </div>
            <nav class="sidebar-nav">
                <div class="nav-section">
                    <div class="nav-section-title">Main</div>
                    <a class="nav-item active" onclick="switchPage('dashboard')">
                        <span class="nav-icon">📊</span>
                        <span>Dashboard</span>
                        <span class="nav-badge" id="navContainerCount">0</span>
                    </a>
                    <a class="nav-item" onclick="switchPage('hosts')">
                        <span class="nav-icon">🖥️</span>
                        <span>Host Management</span>
                    </a>
                    <a class="nav-item" onclick="switchPage('alerts')">
                        <span class="nav-icon">⚡</span>
                        <span>Alert Rules</span>
                        <span class="nav-badge" id="navAlertCount">0</span>
                    </a>
                </div>
                <div class="nav-section">
                    <div class="nav-section-title">Configuration</div>
                    <a class="nav-item" onclick="openGlobalSettings()">
                        <span class="nav-icon">⚙️</span>
                        <span>Settings</span>
                    </a>
                    <a class="nav-item" onclick="openNotificationSettings()">
                        <span class="nav-icon">🔔</span>
                        <span>Notifications</span>
                    </a>
                </div>
                <div class="nav-section">
                    <div class="nav-section-title">System</div>
                    <a class="nav-item" onclick="switchPage('logs')">
                        <span class="nav-icon">📋</span>
                        <span>Logs</span>
                    </a>
                    <a class="nav-item" onclick="switchPage('about')">
                        <span class="nav-icon">ℹ️</span>
                        <span>About</span>
                    </a>
                </div>
            </nav>
        </aside>

        <!-- Main Content -->
        <main class="main-content">
            <!-- Top Bar -->
            <header class="topbar">
                <button class="menu-toggle" onclick="toggleSidebar()">☰</button>
                <h1 class="topbar-title" id="pageTitle">Dashboard</h1>
                <div class="topbar-actions">
                    <button class="btn btn-secondary" onclick="refreshAll()">
                        <span>🔄</span> Refresh
                    </button>
                    <button class="btn btn-primary" onclick="openHostModal()">
                        <span>➕</span> Add Host
                    </button>
                </div>
            </header>

            <!-- Content Area -->
            <div class="content">
                <!-- Dashboard Page -->
                <div id="dashboard-page" class="page-section active">
                    <!-- Dashboard Actions -->
                    <div style="margin-bottom: var(--spacing-lg); display: flex; gap: var(--spacing-md);">
                        <button class="btn btn-secondary" onclick="toggleDashboardLock()" id="dashboardLockBtn">
                            <span id="lockBtnIcon">🔓</span> <span id="lockBtnText">Lock Dashboard</span>
                        </button>
                        <button class="btn btn-secondary" onclick="resetDashboardLayout()">
                            🔄 Reset Layout
                        </button>
                    </div>

                    <!-- GridStack Container -->
                    <div class="grid-stack" id="dashboard-grid">
                        <!-- Widgets will be dynamically added here -->
                    </div>
                </div>

                <!-- Hosts Management Page -->
                <div id="hosts-page" class="page-section">
                    <div class="card">
                        <div class="card-header">
                            <h2 class="card-title">
                                <span>🖥️</span> Docker Hosts
                            </h2>
                            <button class="btn btn-primary" onclick="openHostModal()">
                                Add New Host
                            </button>
                        </div>
                        <div id="hostsList">
                            <!-- Hosts list will be rendered here -->
                        </div>
                    </div>
                </div>

                <!-- Alert Rules Page -->
                <div id="alerts-page" class="page-section">
                    <div class="card">
                        <div class="card-header">
                            <h2 class="card-title">
                                <span>⚡</span> Alert Rules
                            </h2>
                            <button class="btn btn-primary" onclick="openAlertRuleModal()">
                                Create Rule
                            </button>
                        </div>
                        <div id="alertRulesList">
                            <!-- Alert rules will be rendered here -->
                        </div>
                    </div>
                </div>

                <!-- Logs Page -->
                <div id="logs-page" class="page-section">
                    <div class="card">
                        <div class="card-header">
                            <h2 class="card-title">
                                <span>📋</span> System Logs
                            </h2>
                        </div>
                        <div style="padding: var(--spacing-lg); text-align: center; color: var(--text-tertiary);">
                            <p>Log viewer coming soon...</p>
                        </div>
                    </div>
                </div>

                <!-- About Page -->
                <div id="about-page" class="page-section">
                    <div class="card">
                        <div class="card-header">
                            <h2 class="card-title">
                                <span>ℹ️</span> About
                            </h2>
                        </div>
                        <div style="padding: var(--spacing-lg); color: var(--text-secondary);">
                            <p><strong>Docker Monitor v1.0.0</strong></p>
                            <p style="margin-top: var(--spacing-md);">A modern web-based Docker container monitoring solution with real-time alerts and auto-restart capabilities.</p>
                            <p style="margin-top: var(--spacing-md);">Features:</p>
                            <ul style="margin-left: var(--spacing-lg); margin-top: var(--spacing-sm);">
                                <li>Multi-host Docker monitoring</li>
                                <li>Container auto-restart with configurable retries</li>
                                <li>Multi-channel alerting (Telegram, Discord, Pushover)</li>
                                <li>Real-time status updates</li>
                                <li>Modern, responsive interface</li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </main>
    </div>

    <!-- Modals -->
    <!-- Add Host Modal -->
    <div class="modal" id="hostModal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 class="modal-title">Add Docker Host</h2>
                <button class="modal-close" onclick="closeModal('hostModal')">✕</button>
            </div>
            <form onsubmit="addHost(event)">
                <div class="form-group">
                    <label class="form-label">Host Name</label>
                    <input type="text" name="hostname" class="form-input" placeholder="Production Server" required>
                </div>
                <div class="form-group">
                    <label class="form-label">Host URL</label>
                    <input type="text" name="hosturl" class="form-input" placeholder="tcp://192.168.1.100:2376" required>
                </div>
                <div class="form-group">
                    <label class="form-label">API Key (Optional)</label>
                    <input type="text" class="form-input" placeholder="Enter API key if required">
                </div>
                <button type="submit" class="btn btn-primary" style="width: 100%;">
                    Add Host
                </button>
            </form>
        </div>
    </div>

    <!-- Alert Rule Modal -->
    <div class="modal" id="alertRuleModal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 class="modal-title">Create Alert Rule</h2>
                <button class="modal-close" onclick="closeModal('alertRuleModal')">✕</button>
            </div>
            <form onsubmit="createAlertRule(event)">
                <div class="form-group">
                    <label class="form-label">Rule Name</label>
                    <input type="text" class="form-input" id="alertRuleName" placeholder="Enter a name for this alert rule" required>
                </div>
                <div class="form-group">
                    <label class="form-label">Select Container</label>
                    <select class="form-input" id="containerSelect" required>
                        <!-- Options will be populated dynamically -->
                    </select>
                </div>
                <div class="form-group">
                    <label class="form-label">Monitor States</label>
                    <div class="checkbox-group">
                        <label class="checkbox-item">
                            <input type="checkbox" checked data-state="exited"> Running → Exited
                        </label>
                        <label class="checkbox-item">
                            <input type="checkbox" data-state="stopped"> Running → Stopped
                        </label>
                        <label class="checkbox-item">
                            <input type="checkbox" checked data-state="paused"> Running → Paused
                        </label>
                        <label class="checkbox-item">
                            <input type="checkbox" data-state="running"> Stopped → Running
                        </label>
                        <label class="checkbox-item">
                            <input type="checkbox" data-state="running"> Paused → Running
                        </label>
                        <label class="checkbox-item">
                            <input type="checkbox" data-state="running"> Exited → Running
                        </label>
                        <label class="checkbox-item">
                            <input type="checkbox" checked data-state="error"> Any → Error
                        </label>
                    </div>
                </div>
                <div class="form-group">
                    <label class="form-label">Alert Channels</label>
                    <div id="notificationChannelsSection">
                        <p style="color: var(--text-tertiary); font-size: 14px; margin-bottom: 15px;">
                            Configure notification channels first in Settings to enable alerts.
                        </p>
                        <button type="button" class="btn btn-secondary" onclick="openNotificationSettings()">
                            Configure Channels
                        </button>
                    </div>
                </div>
                <button type="submit" class="btn btn-primary" style="width: 100%;">
                    Create Alert Rule
                </button>
            </form>
        </div>
    </div>

    <!-- Global Settings Modal -->
    <div class="modal" id="globalSettingsModal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 class="modal-title">Global Settings</h2>
                <button class="modal-close" onclick="closeModal('globalSettingsModal')">✕</button>
            </div>
            <div class="settings-section">
                <h3 style="margin-bottom: var(--spacing-lg); color: var(--text-primary);">Auto-Restart Configuration</h3>
                <div class="settings-row">
                    <div class="settings-label">
                        <div class="settings-title">Maximum Retry Attempts</div>
                        <div class="settings-description">Number of times to attempt restarting a container before giving up</div>
                    </div>
                    <div class="settings-value">
                        <input type="number" class="number-input" id="maxRetries" min="0" max="10">
                        <span style="font-size: 14px; color: var(--text-tertiary);">retries</span>
                    </div>
                </div>
                <div class="settings-row">
                    <div class="settings-label">
                        <div class="settings-title">Retry Delay</div>
                        <div class="settings-description">Time to wait between restart attempts</div>
                    </div>
                    <div class="settings-value">
                        <input type="number" class="number-input" id="retryDelay" min="5" max="300">
                        <span style="font-size: 14px; color: var(--text-tertiary);">seconds</span>
                    </div>
                </div>
                <div class="settings-row">
                    <div class="settings-label">
                        <div class="settings-title">Enable Auto-Restart by Default</div>
                        <div class="settings-description">New containers will have auto-restart enabled automatically</div>
                    </div>
                    <div class="settings-value">
                        <div class="toggle-switch" id="defaultAutoRestart" onclick="toggleSwitch(this)"></div>
                    </div>
                </div>
            </div>
            <div class="settings-section">
                <h3 style="margin-bottom: var(--spacing-lg); color: var(--text-primary);">Monitoring Settings</h3>
                <div class="settings-row">
                    <div class="settings-label">
                        <div class="settings-title">Polling Interval</div>
                        <div class="settings-description">How often to check container states</div>
                    </div>
                    <div class="settings-value">
                        <input type="number" class="number-input" id="pollingInterval" min="5" max="60">
                        <span style="font-size: 14px; color: var(--text-tertiary);">seconds</span>
                    </div>
                </div>
                <div class="settings-row">
                    <div class="settings-label">
                        <div class="settings-title">Connection Timeout</div>
                        <div class="settings-description">Maximum time to wait for host response</div>
                    </div>
                    <div class="settings-value">
                        <input type="number" class="number-input" id="connectionTimeout" min="5" max="30">
                        <span style="font-size: 14px; color: var(--text-tertiary);">seconds</span>
                    </div>
                </div>
            </div>
            <button class="btn btn-primary" style="width: 100%;" onclick="saveGlobalSettings()">
                Save Settings
            </button>
        </div>
    </div>

    <!-- Notification Settings Modal -->
    <div class="modal" id="notificationModal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 class="modal-title">Notification Settings</h2>
                <button class="modal-close" onclick="closeModal('notificationModal')">✕</button>
            </div>
            <form onsubmit="saveNotificationSettings(event)">
                <div class="form-group">
                    <h3 style="margin-bottom: var(--spacing-md); color: var(--text-primary);">Telegram Configuration</h3>
                    <label class="form-label">Bot Token</label>
                    <input type="text" class="form-input" placeholder="Enter Telegram bot token">
                    <label class="form-label" style="margin-top: var(--spacing-md);">Chat ID</label>
                    <input type="text" class="form-input" placeholder="Enter chat ID">
                </div>
                <div class="form-group">
                    <h3 style="margin-bottom: var(--spacing-md); color: var(--text-primary);">Discord Configuration</h3>
                    <label class="form-label">Webhook URL</label>
                    <input type="text" class="form-input" placeholder="Enter Discord webhook URL">
                </div>
                <div class="form-group">
                    <h3 style="margin-bottom: var(--spacing-md); color: var(--text-primary);">Pushover Configuration</h3>
                    <label class="form-label">App Token</label>
                    <input type="text" class="form-input" placeholder="Enter Pushover app token">
                    <label class="form-label" style="margin-top: var(--spacing-md);">User Key</label>
                    <input type="text" class="form-input" placeholder="Enter user key">
                </div>
                <button type="submit" class="btn btn-primary" style="width: 100%;">
                    Save Settings
                </button>
            </form>
        </div>
    </div>

    <!-- Container Details Modal -->
    <div class="modal" id="containerModal">
        <div class="modal-content" style="max-width: 900px;">
            <div class="modal-header">
                <h2 class="modal-title">Container Details</h2>
                <button class="modal-close" onclick="closeModal('containerModal')">✕</button>
            </div>
            <div id="containerDetails">
                <!-- Container info will be populated here -->
            </div>
            <div style="margin-top: 20px;">
                <ul style="display: flex; gap: 10px; list-style: none; border-bottom: 1px solid var(--border); margin-bottom: 20px;">
                    <li><button class="btn btn-secondary" onclick="showTab('info')" id="tab-info">Info</button></li>
                    <li><button class="btn btn-secondary" onclick="showTab('logs')" id="tab-logs">Logs</button></li>
                    <li><button class="btn btn-secondary" onclick="showTab('exec')" id="tab-exec">Execute Command</button></li>
                </ul>
                
                <!-- Info Tab -->
                <div id="info-tab" class="tab-content">
                    <div id="container-info-content"></div>
                </div>
                
                <!-- Logs Tab -->
                <div id="logs-tab" class="tab-content" style="display: none;">
                    <div style="display: flex; gap: 10px; margin-bottom: 10px;">
                        <button class="btn btn-secondary" onclick="fetchContainerLogs()">Refresh Logs</button>
                        <button class="btn btn-secondary" id="streamLogsBtn" onclick="toggleLogStream()">Start Live Stream</button>
                        <input type="number" id="logTailCount" value="100" min="1" max="1000" style="width: 80px; padding: 8px;" placeholder="Lines">
                    </div>
                    <div id="container-logs" style="background: var(--dark); padding: 15px; border-radius: 6px; max-height: 400px; overflow-y: auto; font-family: 'Monaco', 'Courier New', monospace; font-size: 12px; white-space: pre-wrap; word-break: break-all;">
                        <div style="color: var(--text-tertiary);">Click "Refresh Logs" to load container logs...</div>
                    </div>
                </div>
                
                <!-- Exec Tab -->
                <div id="exec-tab" class="tab-content" style="display: none;">
                    <div style="margin-bottom: 10px;">
                        <input type="text" id="exec-command" class="form-input" placeholder="Enter command (e.g., ls -la, ps aux, cat /etc/hostname)" onkeypress="if(event.key==='Enter') executeCommand()">
                        <button class="btn btn-primary" style="margin-top: 10px;" onclick="executeCommand()">Execute</button>
                    </div>
                    <div style="display: flex; gap: 10px; margin-bottom: 10px;">
                        <button class="btn btn-secondary" onclick="setCommand('ls -la')">ls -la</button>
                        <button class="btn btn-secondary" onclick="setCommand('ps aux')">ps aux</button>
                        <button class="btn btn-secondary" onclick="setCommand('cat /etc/hostname')">hostname</button>
                        <button class="btn btn-secondary" onclick="setCommand('df -h')">df -h</button>
                        <button class="btn btn-secondary" onclick="setCommand('env')">env</button>
                    </div>
                    <div id="exec-output" style="background: var(--dark); padding: 15px; border-radius: 6px; max-height: 400px; overflow-y: auto; font-family: 'Monaco', 'Courier New', monospace; font-size: 12px; white-space: pre-wrap; word-break: break-all;">
                        <div style="color: var(--text-tertiary);">Command output will appear here...</div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Toast Notification -->
    <div class="toast" id="toast"></div>

    <script>
        console.log('DockMon JavaScript loaded');
        // Global state
        let currentPage = 'dashboard';
        let globalSettings = {
            maxRetries: 3,
            retryDelay: 30,
            defaultAutoRestart: false,
            pollingInterval: 10,
            connectionTimeout: 10
        };

        let hosts = [];
        let containers = [];
        let alertRules = [];
        let ws = null;
        let reconnectInterval = null;
        let editingAlertRule = null; // Track which rule is being edited
        let reconnectAttempts = 0;
        let isConnecting = false; // Prevent multiple simultaneous connections
        const MAX_RECONNECT_ATTEMPTS = 10;

        // API Base URL - backend always runs on port 8080
        const API_BASE = `${window.location.protocol}//${window.location.hostname}:8080`;
        const WS_URL = `${window.location.protocol === 'https:' ? 'wss:' : 'ws:'}//${window.location.hostname}:8080/ws`;

        // Initialize WebSocket connection
        function connectWebSocket() {
            // Prevent multiple simultaneous connection attempts
            if (isConnecting) {
                console.log('Connection attempt already in progress, skipping...');
                return;
            }

            // Close existing connection if any
            if (ws && ws.readyState !== WebSocket.CLOSED) {
                ws.close();
            }

            console.log('Connecting to WebSocket:', WS_URL);
            isConnecting = true;

            ws = new WebSocket(WS_URL);
            
            ws.onopen = function() {
                console.log('WebSocket connected');
                showToast('✅ Connected to backend');
                reconnectAttempts = 0;
                isConnecting = false;
                if (reconnectInterval) {
                    clearInterval(reconnectInterval);
                    reconnectInterval = null;
                }
            };
            
            ws.onmessage = function(event) {
                const message = JSON.parse(event.data);
                handleWebSocketMessage(message);
            };
            
            ws.onerror = function(error) {
                console.error('WebSocket error:', error);
                showToast('⚠️ Connection error');
                isConnecting = false; // Reset flag on error
            };

            ws.onclose = function() {
                console.log('WebSocket disconnected');
                showToast('🔌 Disconnected - attempting to reconnect...');
                isConnecting = false; // Reset flag on close
                attemptReconnect();
            };
        }

        // Handle incoming WebSocket messages
        function handleWebSocketMessage(message) {
            console.log('WebSocket message:', message.type);

            switch(message.type) {
                case 'initial_state':
                    hosts = message.data.hosts || [];
                    containers = message.data.containers || [];
                    globalSettings = message.data.settings || globalSettings;
                    alertRules = message.data.alerts || [];
                    console.log('Received initial state - hosts:', hosts.length, 'containers:', containers.length);
                    console.log('Current page:', currentPage, 'Grid exists:', grid !== null);

                    renderAll();

                    // Initialize dashboard if we're on that page
                    if (currentPage === 'dashboard') {
                        if (grid === null) {
                            console.log('Initializing dashboard with WebSocket data...');
                            setTimeout(() => initDashboard(), 100);
                        } else {
                            console.log('Refreshing existing dashboard widgets...');
                            renderDashboardWidgets();
                        }
                    }
                    break;

                case 'containers_update':
                    containers = message.data.containers || [];
                    hosts = message.data.hosts || [];
                    renderAll();

                    // Refresh container modal if open
                    refreshContainerModalIfOpen();
                    break;
                    
                case 'host_added':
                    fetchHosts();
                    showToast('✅ Host added successfully');
                    break;
                    
                case 'auto_restart_success':
                    showToast(`✅ Successfully restarted ${message.data.container_name}`);
                    break;
                    
                case 'auto_restart_failed':
                    showToast(`❌ Failed to restart ${message.data.container_name} after ${message.data.attempts} attempts`);
                    break;
                    
                case 'container_restarted':
                    showToast(`🔄 Container restarted`);
                    break;
                    
                default:
                    console.log('Unknown message type:', message.type);
            }
        }

        // Attempt to reconnect to WebSocket
        function attemptReconnect() {
            if (reconnectAttempts >= MAX_RECONNECT_ATTEMPTS) {
                showToast('❌ Could not reconnect to backend');
                return;
            }

            // Clear any existing reconnect interval
            if (reconnectInterval) {
                clearInterval(reconnectInterval);
                reconnectInterval = null;
            }

            // Use exponential backoff: 2s, 4s, 8s, 16s, then 30s
            const delay = Math.min(2000 * Math.pow(2, reconnectAttempts), 30000);

            console.log(`Will attempt reconnect in ${delay}ms (attempt ${reconnectAttempts + 1}/${MAX_RECONNECT_ATTEMPTS})`);

            setTimeout(() => {
                reconnectAttempts++;
                console.log(`Reconnect attempt ${reconnectAttempts}/${MAX_RECONNECT_ATTEMPTS}`);
                connectWebSocket();
            }, delay);
        }

        // API Functions
        async function fetchHosts() {
            try {
                const response = await fetch(`${API_BASE}/api/hosts`);
                if (response.ok) {
                    hosts = await response.json();
                    console.log('Fetched hosts:', hosts.length);
                } else {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
            } catch (error) {
                console.error('Error fetching hosts:', error);
                // Don't show toast during initial load, WebSocket will handle it
                if (hosts.length === 0) {
                    console.log('Will wait for WebSocket data...');
                } else {
                    showToast('❌ Failed to fetch hosts');
                }
            }
        }

        async function fetchContainers() {
            try {
                const response = await fetch(`${API_BASE}/api/containers`);
                if (response.ok) {
                    containers = await response.json();
                    console.log('Fetched containers:', containers.length);
                } else {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
            } catch (error) {
                console.error('Error fetching containers:', error);
                // Don't show toast during initial load, WebSocket will handle it
                if (containers.length === 0) {
                    console.log('Will wait for WebSocket data...');
                } else {
                    showToast('❌ Failed to fetch containers');
                }
            }
        }

        async function fetchSettings() {
            try {
                const response = await fetch(`${API_BASE}/api/settings`);
                globalSettings = await response.json();
            } catch (error) {
                console.error('Error fetching settings:', error);
            }
        }

        async function fetchAlertRules() {
            try {
                const response = await fetch(`${API_BASE}/api/alerts`);
                if (response.ok) {
                    alertRules = await response.json() || [];
                    renderAlertRules();
                    updateNavBadges();
                } else {
                    console.warn('Failed to fetch alert rules:', response.status);
                    alertRules = [];
                }
            } catch (error) {
                console.error('Error fetching alert rules:', error);
                alertRules = [];
            }
        }

        // Initialize
        async function init() {
            console.log('Starting initialization...');

            // First establish WebSocket connection with a small delay
            connectWebSocket();

            // Give WebSocket a moment to connect, then fetch data as fallback
            await new Promise(resolve => setTimeout(resolve, 1000));

            // Fetch initial data with fallback handling
            console.log('Fetching initial data...');
            const results = await Promise.allSettled([
                fetchHosts(),
                fetchContainers(),
                fetchSettings(),
                fetchAlertRules()
            ]);

            // Check results but don't fail initialization
            results.forEach((result, index) => {
                const names = ['hosts', 'containers', 'settings', 'alertRules'];
                if (result.status === 'rejected') {
                    console.warn(`Failed to fetch ${names[index]}:`, result.reason);
                } else {
                    console.log(`Successfully fetched ${names[index]}`);
                }
            });

            console.log('Rendering initial UI...');
            renderAll();
            console.log('Initialization completed successfully');
        }

        function renderAll() {
            renderHosts();
            renderAlertRules();
            updateStats();
            updateNavBadges();
        }

        // Page switching
        function switchPage(page) {
            // Update active nav item
            document.querySelectorAll('.nav-item').forEach(item => {
                item.classList.remove('active');
            });
            event.currentTarget.classList.add('active');

            // Hide all pages
            document.querySelectorAll('.page-section').forEach(section => {
                section.classList.remove('active');
            });

            // Show selected page
            document.getElementById(`${page}-page`).classList.add('active');
            currentPage = page;

            // Initialize dashboard when switching to it
            if (page === 'dashboard') {
                if (grid === null) {
                    setTimeout(() => initDashboard(), 100); // Delay to ensure DOM is ready
                } else {
                    renderDashboardWidgets(); // Refresh existing widgets
                }
            }

            // Update page title
            const titles = {
                'dashboard': 'Dashboard',
                'hosts': 'Host Management',
                'alerts': 'Alert Rules',
                'logs': 'System Logs',
                'about': 'About'
            };
            document.getElementById('pageTitle').textContent = titles[page] || 'Dashboard';
            
            currentPage = page;
            
            // Render page-specific content
            if (page === 'hosts') {
                renderHostsPage();
            } else if (page === 'alerts') {
                renderAlertsPage();
            }
        }

        // Render functions
        function renderHosts() {
            // If on dashboard page, update widgets
            if (currentPage === 'dashboard') {
                renderDashboardWidgets();
                return;
            }

            const hostsGrid = document.getElementById('hostsGrid');
            if (!hostsGrid) return;
            hostsGrid.innerHTML = '';

            // Group containers by host
            const containersByHost = {};
            hosts.forEach(host => {
                containersByHost[host.id] = [];
            });
            
            containers.forEach(container => {
                if (containersByHost[container.host_id]) {
                    containersByHost[container.host_id].push(container);
                }
            });
            
            hosts.forEach(host => {
                const hostCard = document.createElement('div');
                hostCard.className = 'host-card';
                
                const hostContainers = (containersByHost[host.id] || []).sort((a, b) => a.name.localeCompare(b.name));
                const containersList = hostContainers.map(container => `
                    <div class="container-item">
                        <div class="container-info" onclick="showContainerDetails('${container.short_id}')">
                            <div class="container-icon container-${container.state}">
                                ${getContainerIcon(container.state)}
                            </div>
                            <div class="container-details">
                                <div class="container-name">${container.name}</div>
                                <div class="container-id">${container.short_id}</div>
                            </div>
                        </div>
                        <div class="container-actions">
                            <div class="auto-restart-toggle ${container.auto_restart ? 'enabled' : ''}" 
                                 onclick="event.stopPropagation()">
                                <span>🔄 Auto</span>
                                <div class="toggle-switch ${container.auto_restart ? 'active' : ''}" 
                                     onclick="toggleAutoRestart('${container.host_id}', '${container.short_id}', event)"></div>
                            </div>
                            <span class="container-state ${getStateClass(container.state)}">
                                ${container.state}
                            </span>
                        </div>
                    </div>
                `).join('');
                
                hostCard.innerHTML = `
                    <div class="host-header">
                        <div class="host-name">
                            <span>🖥️</span> ${host.name}
                        </div>
                        <span class="host-status status-${host.status}">${host.status}</span>
                    </div>
                    <div class="container-list">
                        ${containersList || '<div style="padding: 12px; color: var(--text-tertiary); text-align: center;">No containers</div>'}
                    </div>
                `;
                
                hostsGrid.appendChild(hostCard);
            });
        }

        function renderHostsPage() {
            const hostsList = document.getElementById('hostsList');
            hostsList.innerHTML = hosts.map(host => {
                const hostContainers = containers.filter(c => c.host_id === host.id);
                return `
                    <div class="alert-rule-card">
                        <div class="alert-rule-info">
                            <div class="alert-rule-title">${host.name}</div>
                            <div class="alert-rule-details">${host.url} • ${hostContainers.length} containers</div>
                            <div class="alert-rule-details" style="margin-top: 4px;">
                                Status: <span class="status-${host.status}">${host.status}</span>
                                ${host.error ? `• Error: ${host.error}` : ''}
                            </div>
                        </div>
                        <div style="display: flex; gap: var(--spacing-sm);">
                            <button class="btn-icon" onclick="editHost('${host.id}')">✏️</button>
                            <button class="btn-icon" onclick="deleteHost('${host.id}')">🗑️</button>
                        </div>
                    </div>
                `;
            }).join('');
        }

        function renderAlertsPage() {
            renderAlertRules();
        }

        function renderAlertRules() {
            try {
                const alertRulesList = document.getElementById('alertRulesList');
                if (!alertRulesList) return;

                alertRulesList.innerHTML = '';

                if (!alertRules || !Array.isArray(alertRules)) {
                    console.warn('alertRules is not an array:', alertRules);
                    return;
                }

                alertRules.forEach(rule => {
                const ruleCard = document.createElement('div');
                ruleCard.className = 'alert-rule-card';

                const channelBadges = (rule.notification_channels || []).map(channel =>
                    `<span class="channel-badge channel-${channel}">${channel}</span>`
                ).join('');

                ruleCard.innerHTML = `
                    <div class="alert-rule-info">
                        <div class="alert-rule-title">${rule.name || rule.container_pattern}</div>
                        <div class="alert-rule-details">Container: ${rule.container_pattern} | States: ${(rule.trigger_states || []).join(', ')}</div>
                        <div class="alert-channels">${channelBadges}</div>
                    </div>
                    <div class="alert-rule-actions">
                        <button class="btn-icon" onclick="editAlertRule('${rule.id}')" title="Edit Alert Rule">
                            ✏️
                        </button>
                        <button class="btn-icon" onclick="deleteAlertRule('${rule.id}')" title="Delete Alert Rule">
                            🗑️
                        </button>
                    </div>
                `;
                
                alertRulesList.appendChild(ruleCard);
                });
            } catch (error) {
                console.error('Error rendering alert rules:', error);
            }
        }

        // Update functions
        function updateStats() {
            // Stats are now handled by dashboard widgets
            // Only update if we're not on the dashboard page (for backward compatibility)
            if (currentPage !== 'dashboard') {
                const totalHostsEl = document.getElementById('totalHosts');
                const totalContainersEl = document.getElementById('totalContainers');
                const runningContainersEl = document.getElementById('runningContainers');
                const alertRulesEl = document.getElementById('alertRules');

                if (totalHostsEl) totalHostsEl.textContent = hosts.length;
                if (totalContainersEl) totalContainersEl.textContent = containers.length;
                if (runningContainersEl) runningContainersEl.textContent = containers.filter(c => c.state === 'running').length;
                if (alertRulesEl) alertRulesEl.textContent = alertRules.length;
            }
        }

        function updateNavBadges() {
            const navContainerCountEl = document.getElementById('navContainerCount');
            const navAlertCountEl = document.getElementById('navAlertCount');

            if (navContainerCountEl) navContainerCountEl.textContent = containers.length;
            if (navAlertCountEl) navAlertCountEl.textContent = alertRules.length;
        }

        // Helper functions
        function getContainerIcon(state) {
            switch(state) {
                case 'running': return '▶';
                case 'exited': return '■';
                case 'paused': return '⏸';
                default: return '?';
            }
        }

        function getStateClass(state) {
            switch(state) {
                case 'running': return 'status-online';
                case 'exited': return 'status-offline';
                case 'paused': return 'channel-pushover';
                default: return '';
            }
        }

        // Modal functions
        function openHostModal() {
            document.getElementById('hostModal').classList.add('active');
        }

        function openAlertRuleModal(preselectedContainer = null, editRule = null) {
            // Update modal title and button text based on mode
            const modalTitle = document.querySelector('#alertRuleModal .modal-title');
            const submitButton = document.querySelector('#alertRuleModal button[type="submit"]');

            if (editRule) {
                modalTitle.textContent = 'Edit Alert Rule';
                submitButton.textContent = 'Update Alert Rule';
                // Populate form with existing rule data
                document.getElementById('alertRuleName').value = editRule.name || '';
            } else {
                modalTitle.textContent = 'Create Alert Rule';
                submitButton.textContent = 'Create Alert Rule';
                // Clear the form
                document.getElementById('alertRuleName').value = '';
                editingAlertRule = null;
            }

            // Populate container dropdown with all available containers
            const containerSelect = document.getElementById('containerSelect');
            containerSelect.innerHTML = '';

            // Group containers by host for better organization
            const containersByHost = {};
            hosts.forEach(host => {
                containersByHost[host.id] = { name: host.name, containers: [] };
            });

            containers.forEach(container => {
                if (containersByHost[container.host_id]) {
                    containersByHost[container.host_id].containers.push(container);
                }
            });

            // Add options to select
            Object.values(containersByHost).forEach(hostData => {
                if (hostData.containers.length > 0) {
                    hostData.containers.forEach(container => {
                        const option = document.createElement('option');
                        option.value = `${container.host_id}:${container.id}`;
                        option.textContent = `${hostData.name} / ${container.name}`;

                        // Pre-select if specified or if editing and matches pattern
                        if (preselectedContainer && container.id === preselectedContainer.id) {
                            option.selected = true;
                        } else if (editRule && container.name === editRule.container_pattern) {
                            option.selected = true;
                        }

                        containerSelect.appendChild(option);
                    });
                }
            });

            // Populate notification channels
            populateNotificationChannels();

            // If editing, populate form fields
            if (editRule) {
                // Set trigger state checkboxes
                setTimeout(() => {
                    // Clear all checkboxes first
                    document.querySelectorAll('#alertRuleModal input[type="checkbox"]').forEach(cb => cb.checked = false);

                    // Check boxes based on rule's trigger_states
                    if (editRule.trigger_states && editRule.trigger_states.includes('exited')) {
                        const exitedCheckbox = document.querySelector('input[type="checkbox"][data-state="exited"]');
                        if (exitedCheckbox) exitedCheckbox.checked = true;
                    }
                    if (editRule.trigger_states && editRule.trigger_states.includes('stopped')) {
                        const stoppedCheckbox = document.querySelector('input[type="checkbox"][data-state="stopped"]');
                        if (stoppedCheckbox) stoppedCheckbox.checked = true;
                    }
                    if (editRule.trigger_states && editRule.trigger_states.includes('paused')) {
                        const pausedCheckbox = document.querySelector('input[type="checkbox"][data-state="paused"]');
                        if (pausedCheckbox) pausedCheckbox.checked = true;
                    }
                    if (editRule.trigger_states && editRule.trigger_states.includes('error')) {
                        const errorCheckbox = document.querySelector('input[type="checkbox"][data-state="error"]');
                        if (errorCheckbox) errorCheckbox.checked = true;
                    }

                    // Set notification channels
                    if (editRule.notification_channels) {
                        editRule.notification_channels.forEach(channelId => {
                            const channelCheckbox = document.querySelector(`input[type="checkbox"][data-channel-id="${channelId}"]`);
                            if (channelCheckbox) channelCheckbox.checked = true;
                        });
                    }
                }, 100); // Small delay to ensure notification channels are loaded
            }

            document.getElementById('alertRuleModal').classList.add('active');
        }

        async function populateNotificationChannels() {
            try {
                const response = await fetch(`${API_BASE}/api/notifications/channels`);
                const channels = await response.json();

                const channelsSection = document.getElementById('notificationChannelsSection');

                if (channels && channels.length > 0) {
                    // Show available channels as checkboxes
                    let channelsHtml = '<div class="checkbox-group">';
                    channels.forEach(channel => {
                        channelsHtml += `
                            <label class="checkbox-item">
                                <input type="checkbox" name="channels" value="${channel.id}" data-channel-id="${channel.id}">
                                ${channel.name} (${channel.type})
                            </label>
                        `;
                    });
                    channelsHtml += '</div>';

                    channelsSection.innerHTML = channelsHtml;
                } else {
                    // No channels configured yet
                    channelsSection.innerHTML = `
                        <p style="color: var(--text-tertiary); font-size: 14px; margin-bottom: 15px;">
                            No notification channels configured yet. Set up Discord, Telegram, or Pushover to receive alerts.
                        </p>
                        <button type="button" class="btn btn-secondary" onclick="openNotificationSettings()">
                            Configure Channels
                        </button>
                    `;
                }
            } catch (error) {
                console.error('Error fetching notification channels:', error);
                const channelsSection = document.getElementById('notificationChannelsSection');
                channelsSection.innerHTML = `
                    <p style="color: var(--text-tertiary); font-size: 14px; margin-bottom: 15px;">
                        Configure notification channels first in Settings to enable alerts.
                    </p>
                    <button type="button" class="btn btn-secondary" onclick="openNotificationSettings()">
                        Configure Channels
                    </button>
                `;
            }
        }

        async function openNotificationSettings() {
            await loadNotificationSettings();
            document.getElementById('notificationModal').classList.add('active');
        }

        async function loadNotificationSettings() {
            try {
                const response = await fetch(`${API_BASE}/api/notifications/channels`);
                const channels = await response.json();

                // Clear existing values
                document.querySelectorAll('#notificationModal .form-input').forEach(input => {
                    input.value = '';
                });

                // Populate existing settings
                channels.forEach(channel => {
                    if (channel.type === 'telegram') {
                        const tokenInput = document.querySelector('#notificationModal .form-input[placeholder*="Telegram bot token"]');
                        const chatInput = document.querySelector('#notificationModal .form-input[placeholder*="chat ID"]');
                        if (tokenInput && chatInput && channel.config) {
                            tokenInput.value = channel.config.token || '';
                            chatInput.value = channel.config.chat_id || '';
                        }
                    } else if (channel.type === 'discord') {
                        const webhookInput = document.querySelector('#notificationModal .form-input[placeholder*="Discord webhook"]');
                        if (webhookInput && channel.config) {
                            webhookInput.value = channel.config.webhook_url || '';
                        }
                    } else if (channel.type === 'pushover') {
                        const tokenInput = document.querySelector('#notificationModal .form-input[placeholder*="Pushover app token"]');
                        const userInput = document.querySelector('#notificationModal .form-input[placeholder*="user key"]');
                        if (tokenInput && userInput && channel.config) {
                            tokenInput.value = channel.config.app_token || '';
                            userInput.value = channel.config.user_key || '';
                        }
                    }
                });
            } catch (error) {
                console.error('Error loading notification settings:', error);
            }
        }

        function createAlertForContainer(containerId) {
            // Find the container
            const container = containers.find(c => c.id === containerId);
            if (container) {
                // Close current modal and open alert modal with pre-selected container
                closeModal('containerModal');
                openAlertRuleModal(container);
            }
        }

        async function editAlertRule(ruleId) {
            try {
                // Find the rule in the current alertRules array
                const rule = alertRules.find(r => r.id === ruleId);
                if (!rule) {
                    showToast('❌ Alert rule not found');
                    return;
                }

                editingAlertRule = rule;
                openAlertRuleModal(null, rule);
            } catch (error) {
                console.error('Error opening alert rule for editing:', error);
                showToast('❌ Failed to open alert rule for editing');
            }
        }

        function openGlobalSettings() {
            document.getElementById('maxRetries').value = globalSettings.max_retries;
            document.getElementById('retryDelay').value = globalSettings.retry_delay;
            document.getElementById('pollingInterval').value = globalSettings.polling_interval;
            document.getElementById('connectionTimeout').value = globalSettings.connection_timeout;

            const defaultToggle = document.getElementById('defaultAutoRestart');
            if (globalSettings.default_auto_restart) {
                defaultToggle.classList.add('active');
            } else {
                defaultToggle.classList.remove('active');
            }

            document.getElementById('globalSettingsModal').classList.add('active');
        }

        function closeModal(modalId) {
            document.getElementById(modalId).classList.remove('active');
        }

        function refreshContainerModalIfOpen() {
            const containerModal = document.getElementById('containerModal');
            if (containerModal && containerModal.classList.contains('active') && window.currentContainer) {
                // Find the updated container data using the stored container ID
                const updatedContainer = containers.find(c => c.short_id === window.currentContainer.short_id);
                if (updatedContainer) {
                    // Re-populate the modal with updated data
                    showContainerDetails(updatedContainer.short_id);
                }
            }
        }

        // Toggle functions
        function toggleSwitch(element) {
            element.classList.toggle('active');
        }

        async function toggleAutoRestart(hostId, containerId, event) {
            event.stopPropagation();

            // Find the container to get current state (handle both short_id and full id)
            const container = containers.find(c => c.short_id === containerId || c.id === containerId);
            if (!container) {
                console.error('Container not found:', containerId);
                return;
            }

            const newState = !container.auto_restart;

            try {
                const response = await fetch(`${API_BASE}/api/containers/${container.short_id}/auto-restart`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        host_id: hostId,
                        container_name: container.name,
                        enabled: newState
                    })
                });

                if (response.ok) {
                    // Update local state
                    container.auto_restart = newState;
                    container.restart_attempts = 0;

                    renderHosts();

                    // Update modal content if it's open and showing this container
                    if (window.currentContainer && window.currentContainer.id === container.id) {
                        showContainerDetails(container.short_id);
                    }

                    const status = newState ? 'enabled' : 'disabled';
                    showToast(`🔄 Auto-restart ${status} for ${container.name}`);

                    if (newState && container.state === 'exited') {
                        // Trigger restart attempt
                        restartContainer(hostId, container.id);
                    }
                } else {
                    showToast('❌ Failed to toggle auto-restart');
                }
            } catch (error) {
                console.error('Error toggling auto-restart:', error);
                showToast('❌ Failed to toggle auto-restart');
            }
        }

        // Actions
        async function addHost(event) {
            event.preventDefault();
            const formData = new FormData(event.target);
            
            const hostData = {
                name: formData.get('hostname'),
                url: formData.get('hosturl')
            };
            
            try {
                const response = await fetch(`${API_BASE}/api/hosts`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(hostData)
                });
                
                if (response.ok) {
                    const newHost = await response.json();
                    hosts.push(newHost);
                    renderHosts();
                    updateStats();
                    updateNavBadges();
                    showToast('✅ Host added successfully!');
                    closeModal('hostModal');
                    event.target.reset();
                } else {
                    const error = await response.text();
                    showToast(`❌ Failed to add host: ${error}`);
                }
            } catch (error) {
                console.error('Error adding host:', error);
                showToast('❌ Failed to add host');
            }
        }

        async function createAlertRule(event) {
            event.preventDefault();

            const container = event.target.querySelector('select').value;
            const states = [];
            const channels = [];

            // Get selected states
            event.target.querySelectorAll('input[type="checkbox"]:checked').forEach(cb => {
                if (cb.name === 'channels') {
                    // This is a notification channel
                    channels.push(parseInt(cb.value));
                } else if (cb.dataset.state) {
                    // This is a state change - use data attribute for cleaner mapping
                    states.push(cb.dataset.state);
                } else {
                    // Fallback to text parsing for backwards compatibility
                    states.push(cb.parentElement.textContent.trim().replace(/.*→\s*/, '').toLowerCase());
                }
            });

            // Parse container selection (format: "host_id:container_id")
            const [hostId, containerId] = container.split(':');
            const selectedContainer = containers.find(c => c.host_id === hostId && c.id === containerId);

            const ruleName = document.getElementById('alertRuleName').value;

            const ruleData = {
                name: ruleName,
                host_id: hostId || null,
                container_pattern: selectedContainer ? selectedContainer.name : container,
                trigger_states: states,
                notification_channels: channels,
                cooldown_minutes: 15,
                enabled: true
            };

            const isEditing = editingAlertRule !== null;
            const url = isEditing ? `${API_BASE}/api/alerts/${editingAlertRule.id}` : `${API_BASE}/api/alerts`;
            const method = isEditing ? 'PUT' : 'POST';
            
            try {
                const response = await fetch(url, {
                    method: method,
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(ruleData)
                });
                
                if (response.ok) {
                    const rule = await response.json();

                    if (isEditing) {
                        // Update existing rule in array
                        const index = alertRules.findIndex(r => r.id === editingAlertRule.id);
                        if (index !== -1) {
                            alertRules[index] = rule;
                        }
                        showToast('✅ Alert rule updated successfully!');
                        editingAlertRule = null;
                    } else {
                        // Add new rule to array
                        alertRules.push(rule);
                        showToast('✅ Alert rule created successfully!');
                    }

                    renderAlertRules();
                    updateStats();
                    updateNavBadges();
                    closeModal('alertRuleModal');
                } else {
                    const errorData = await response.json().catch(() => ({ detail: 'Unknown error' }));
                    console.error(`Alert ${isEditing ? 'update' : 'creation'} failed:`, errorData);
                    const errorMessage = typeof errorData.detail === 'string'
                        ? errorData.detail
                        : JSON.stringify(errorData.detail) || response.statusText;
                    showToast(`❌ Failed to ${isEditing ? 'update' : 'create'} alert: ${errorMessage}`);
                }
            } catch (error) {
                console.error(`Error ${editingAlertRule ? 'updating' : 'creating'} alert rule:`, error);
                showToast(`❌ Failed to ${editingAlertRule ? 'update' : 'create'} alert rule`);
            }
        }

        async function saveNotificationSettings(event) {
            event.preventDefault();

            try {
                // Get form values
                const telegramToken = document.querySelector('#notificationModal .form-input[placeholder*="Telegram bot token"]').value;
                const telegramChatId = document.querySelector('#notificationModal .form-input[placeholder*="chat ID"]').value;
                const discordWebhook = document.querySelector('#notificationModal .form-input[placeholder*="Discord webhook"]').value;
                const pushoverToken = document.querySelector('#notificationModal .form-input[placeholder*="Pushover app token"]').value;
                const pushoverUserKey = document.querySelector('#notificationModal .form-input[placeholder*="user key"]').value;

                // Get existing channels to update or create
                const response = await fetch(`${API_BASE}/api/notifications/channels`);
                const existingChannels = await response.json();

                const promises = [];

                // Handle Telegram
                if (telegramToken && telegramChatId) {
                    const telegramChannel = existingChannels.find(ch => ch.type === 'telegram');
                    const telegramData = {
                        name: 'Telegram',
                        type: 'telegram',
                        config: { token: telegramToken, chat_id: telegramChatId },
                        enabled: true
                    };

                    if (telegramChannel) {
                        promises.push(fetch(`${API_BASE}/api/notifications/channels/${telegramChannel.id}`, {
                            method: 'PUT',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                name: telegramData.name,
                                config: telegramData.config,
                                enabled: telegramData.enabled
                            })
                        }));
                    } else {
                        promises.push(fetch(`${API_BASE}/api/notifications/channels`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(telegramData)
                        }));
                    }
                }

                // Handle Discord
                if (discordWebhook) {
                    const discordChannel = existingChannels.find(ch => ch.type === 'discord');
                    const discordData = {
                        name: 'Discord',
                        type: 'discord',
                        config: { webhook_url: discordWebhook },
                        enabled: true
                    };

                    if (discordChannel) {
                        promises.push(fetch(`${API_BASE}/api/notifications/channels/${discordChannel.id}`, {
                            method: 'PUT',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                name: discordData.name,
                                config: discordData.config,
                                enabled: discordData.enabled
                            })
                        }));
                    } else {
                        promises.push(fetch(`${API_BASE}/api/notifications/channels`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(discordData)
                        }));
                    }
                }

                // Handle Pushover
                if (pushoverToken && pushoverUserKey) {
                    const pushoverChannel = existingChannels.find(ch => ch.type === 'pushover');
                    const pushoverData = {
                        name: 'Pushover',
                        type: 'pushover',
                        config: { app_token: pushoverToken, user_key: pushoverUserKey },
                        enabled: true
                    };

                    if (pushoverChannel) {
                        promises.push(fetch(`${API_BASE}/api/notifications/channels/${pushoverChannel.id}`, {
                            method: 'PUT',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                name: pushoverData.name,
                                config: pushoverData.config,
                                enabled: pushoverData.enabled
                            })
                        }));
                    } else {
                        promises.push(fetch(`${API_BASE}/api/notifications/channels`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(pushoverData)
                        }));
                    }
                }

                // Wait for all requests to complete and check for errors
                const responses = await Promise.all(promises);

                // Check if any request failed
                for (const response of responses) {
                    if (!response.ok) {
                        const errorData = await response.json().catch(() => ({ detail: 'Unknown error' }));
                        const errorMessage = typeof errorData.detail === 'string'
                            ? errorData.detail
                            : JSON.stringify(errorData.detail) || response.statusText;
                        throw new Error(`API Error: ${errorMessage}`);
                    }
                }

                showToast('✅ Notification settings saved!');
                closeModal('notificationModal');

                // Refresh notification channels for alert creation
                await populateNotificationChannels();

            } catch (error) {
                console.error('Error saving notification settings:', error);
                showToast(`❌ Failed to save notification settings: ${error.message}`);
            }
        }

        async function saveGlobalSettings() {
            globalSettings.max_retries = parseInt(document.getElementById('maxRetries').value);
            globalSettings.retry_delay = parseInt(document.getElementById('retryDelay').value);
            globalSettings.polling_interval = parseInt(document.getElementById('pollingInterval').value);
            globalSettings.connection_timeout = parseInt(document.getElementById('connectionTimeout').value);
            globalSettings.default_auto_restart = document.getElementById('defaultAutoRestart').classList.contains('active');
            
            try {
                const response = await fetch(`${API_BASE}/api/settings`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(globalSettings)
                });
                
                if (response.ok) {
                    showToast('✅ Settings saved successfully!');
                    closeModal('globalSettingsModal');
                }
            } catch (error) {
                console.error('Error saving settings:', error);
                showToast('❌ Failed to save settings');
            }
        }

        async function deleteAlertRule(ruleId) {
            try {
                const response = await fetch(`${API_BASE}/api/alerts/${ruleId}`, {
                    method: 'DELETE'
                });
                
                if (response.ok) {
                    alertRules = alertRules.filter(rule => rule.id !== ruleId);
                    renderAlertRules();
                    updateStats();
                    updateNavBadges();
                    showToast('Alert rule deleted');
                }
            } catch (error) {
                console.error('Error deleting alert rule:', error);
                showToast('❌ Failed to delete alert rule');
            }
        }

        async function deleteHost(hostId) {
            try {
                const response = await fetch(`${API_BASE}/api/hosts/${hostId}`, {
                    method: 'DELETE'
                });
                
                if (response.ok) {
                    hosts = hosts.filter(host => host.id !== hostId);
                    containers = containers.filter(c => c.host_id !== hostId);
                    renderHostsPage();
                    renderHosts();
                    updateStats();
                    updateNavBadges();
                    showToast('Host removed');
                }
            } catch (error) {
                console.error('Error deleting host:', error);
                showToast('❌ Failed to delete host');
            }
        }

        function editHost(hostId) {
            showToast('Edit functionality coming soon...');
        }

        async function refreshAll() {
            showToast('🔄 Refreshing all containers...');
            await Promise.all([
                fetchHosts(),
                fetchContainers()
            ]);
            renderHosts();
        }

        function showContainerDetails(containerId) {
            const container = containers.find(c => c.short_id === containerId);
            if (container) {
                // Store current container info globally for modal functions
                window.currentContainer = container;
                
                // Populate container details
                const detailsHtml = `
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-bottom: 20px;">
                        <div>
                            <strong>Name:</strong> ${container.name}<br>
                            <strong>ID:</strong> ${container.short_id}<br>
                            <strong>Image:</strong> ${container.image}<br>
                        </div>
                        <div>
                            <strong>State:</strong> <span class="${getStateClass(container.state)}">${container.state}</span><br>
                            <strong>Host:</strong> ${container.host_name}<br>
                            <strong>Created:</strong> ${new Date(container.created).toLocaleString()}<br>
                        </div>
                    </div>
                    <div class="container-actions" style="display: flex; gap: 10px; flex-wrap: wrap;">
                        ${container.state === 'running' ? `
                            <button class="btn btn-danger" onclick="stopContainer('${container.host_id}', '${container.id}')">
                                ⏹️ Stop Container
                            </button>
                        ` : `
                            <button class="btn btn-primary" onclick="startContainer('${container.host_id}', '${container.id}')">
                                ▶️ Start Container
                            </button>
                        `}
                        <button class="btn btn-secondary" onclick="restartContainer('${container.host_id}', '${container.id}')">
                            🔄 Restart Container
                        </button>
                        <button class="btn btn-secondary" onclick="createAlertForContainer('${container.id}')">
                            ⚡ Create Alert
                        </button>
                        <div class="auto-restart-toggle ${container.auto_restart ? 'enabled' : ''}"
                             onclick="toggleAutoRestart('${container.host_id}', '${container.id}', event)">
                            <span>🔄 Auto-restart: ${container.auto_restart ? 'ON' : 'OFF'}</span>
                        </div>
                    </div>
                `;
                
                document.getElementById('container-info-content').innerHTML = detailsHtml;
                
                // Show modal
                document.getElementById('containerModal').classList.add('active');
                
                // Show info tab by default
                showTab('info');
            }
        }

        // Container Modal Functions
        function showTab(tab) {
            // Hide all tabs
            document.querySelectorAll('.tab-content').forEach(content => {
                content.style.display = 'none';
            });
            
            // Remove active class from all tab buttons
            document.querySelectorAll('[id^="tab-"]').forEach(btn => {
                btn.classList.remove('btn-primary');
                btn.classList.add('btn-secondary');
            });
            
            // Show selected tab
            document.getElementById(`${tab}-tab`).style.display = 'block';
            document.getElementById(`tab-${tab}`).classList.remove('btn-secondary');
            document.getElementById(`tab-${tab}`).classList.add('btn-primary');
            
            // Clear log stream if switching away from logs
            if (tab !== 'logs' && window.logStreamWs) {
                window.logStreamWs.close();
                window.logStreamWs = null;
                document.getElementById('streamLogsBtn').textContent = 'Start Live Stream';
            }
        }

        async function fetchContainerLogs() {
            if (!window.currentContainer) return;
            
            const tailCount = document.getElementById('logTailCount').value || 100;
            const logsDiv = document.getElementById('container-logs');
            logsDiv.innerHTML = '<div style="color: var(--text-secondary);">Loading logs...</div>';
            
            try {
                const response = await fetch(
                    `${API_BASE}/api/hosts/${window.currentContainer.host_id}/containers/${window.currentContainer.id}/logs?tail=${tailCount}`
                );
                
                if (response.ok) {
                    const data = await response.json();
                    const logs = data.logs.filter(line => line.trim()).join('\n');
                    logsDiv.innerHTML = logs || '<div style="color: var(--text-tertiary);">No logs available</div>';
                    logsDiv.scrollTop = logsDiv.scrollHeight;
                } else {
                    logsDiv.innerHTML = '<div style="color: var(--danger);">Failed to fetch logs</div>';
                }
            } catch (error) {
                console.error('Error fetching logs:', error);
                logsDiv.innerHTML = '<div style="color: var(--danger);">Error loading logs</div>';
            }
        }

        function toggleLogStream() {
            if (!window.currentContainer) return;
            
            const btn = document.getElementById('streamLogsBtn');
            const logsDiv = document.getElementById('container-logs');
            
            if (window.logStreamWs) {
                // Stop streaming
                window.logStreamWs.close();
                window.logStreamWs = null;
                btn.textContent = 'Start Live Stream';
                return;
            }
            
            // Start streaming - backend always on port 8080
            const wsUrl = `${window.location.protocol === 'https:' ? 'wss:' : 'ws:'}//${window.location.hostname}:8080/ws/logs/${window.currentContainer.host_id}/${window.currentContainer.id}`;
            
            window.logStreamWs = new WebSocket(wsUrl);
            
            window.logStreamWs.onopen = function() {
                btn.textContent = 'Stop Live Stream';
                logsDiv.innerHTML = '<div style="color: var(--success);">Live streaming started...</div>\n';
            };
            
            window.logStreamWs.onmessage = function(event) {
                logsDiv.innerHTML += event.data + '\n';
                
                // Auto-scroll to bottom
                logsDiv.scrollTop = logsDiv.scrollHeight;
                
                // Limit log size to prevent memory issues
                const lines = logsDiv.innerHTML.split('\n');
                if (lines.length > 1000) {
                    logsDiv.innerHTML = lines.slice(-1000).join('\n');
                }
            };
            
            window.logStreamWs.onerror = function(error) {
                console.error('Log stream error:', error);
                btn.textContent = 'Start Live Stream';
                logsDiv.innerHTML += '<div style="color: var(--danger);">Stream error occurred</div>\n';
            };
            
            window.logStreamWs.onclose = function() {
                btn.textContent = 'Start Live Stream';
                if (window.logStreamWs) {
                    logsDiv.innerHTML += '<div style="color: var(--text-tertiary);">Stream closed</div>\n';
                }
                window.logStreamWs = null;
            };
        }

        function setCommand(cmd) {
            document.getElementById('exec-command').value = cmd;
        }

        async function executeCommand() {
            if (!window.currentContainer) return;
            
            const command = document.getElementById('exec-command').value.trim();
            if (!command) {
                showToast('Please enter a command');
                return;
            }
            
            const outputDiv = document.getElementById('exec-output');
            outputDiv.innerHTML = `<div style="color: var(--text-secondary);">Executing: ${command}...</div>\n`;
            
            try {
                const response = await fetch(
                    `${API_BASE}/api/hosts/${window.currentContainer.host_id}/containers/${window.currentContainer.id}/exec?command=${encodeURIComponent(command)}`,
                    { method: 'POST' }
                );
                
                if (response.ok) {
                    const data = await response.json();
                    outputDiv.innerHTML = `<div style="color: var(--text-tertiary);">$ ${data.command}</div>\n`;
                    outputDiv.innerHTML += `<div style="color: var(--text-primary);">${data.output}</div>`;
                    if (data.exit_code !== 0) {
                        outputDiv.innerHTML += `<div style="color: var(--warning);">Exit code: ${data.exit_code}</div>`;
                    }
                } else {
                    outputDiv.innerHTML = `<div style="color: var(--danger);">Failed to execute command</div>`;
                }
            } catch (error) {
                console.error('Error executing command:', error);
                outputDiv.innerHTML = `<div style="color: var(--danger);">Error executing command</div>`;
            }
        }

        async function restartContainer(hostId, containerId) {
            try {
                const response = await fetch(`${API_BASE}/api/hosts/${hostId}/containers/${containerId}/restart`, {
                    method: 'POST'
                });
                
                if (response.ok) {
                    showToast('🔄 Container restarting...');
                } else {
                    showToast('❌ Failed to restart container');
                }
            } catch (error) {
                console.error('Error restarting container:', error);
                showToast('❌ Failed to restart container');
            }
        }

        async function startContainer(hostId, containerId) {
            try {
                const response = await fetch(`${API_BASE}/api/hosts/${hostId}/containers/${containerId}/start`, {
                    method: 'POST'
                });

                if (response.ok) {
                    showToast('▶️ Container starting...');
                } else {
                    showToast('❌ Failed to start container');
                }
            } catch (error) {
                console.error('Error starting container:', error);
                showToast('❌ Failed to start container');
            }
        }

        async function stopContainer(hostId, containerId) {
            try {
                const response = await fetch(`${API_BASE}/api/hosts/${hostId}/containers/${containerId}/stop`, {
                    method: 'POST'
                });

                if (response.ok) {
                    showToast('⏹️ Container stopping...');
                } else {
                    showToast('❌ Failed to stop container');
                }
            } catch (error) {
                console.error('Error stopping container:', error);
                showToast('❌ Failed to stop container');
            }
        }

        function showToast(message) {
            const toast = document.getElementById('toast');
            toast.textContent = message;
            toast.classList.add('show');
            setTimeout(() => {
                toast.classList.remove('show');
            }, 3000);
        }

        // GridStack Dashboard
        let grid = null;
        let dashboardLocked = false;

        function initDashboard() {
            console.log('initDashboard called');

            // Check if dashboard grid container exists
            const dashboardGridElement = document.getElementById('dashboard-grid');
            if (!dashboardGridElement) {
                console.error('Dashboard grid element not found!');
                return;
            }

            // Initialize GridStack with better flexibility
            try {
                grid = GridStack.init({
                    column: 12,      // Keep standard 12 columns
                    cellHeight: 40,  // Smaller cells for better control
                    margin: 4,       // Tighter margins
                    animate: true,
                    float: true,
                    draggable: {
                        handle: '.widget-header'
                    },
                    resizable: {
                        handles: 'e, se, s, sw, w'
                    }
                }, '#dashboard-grid');

                console.log('GridStack initialized successfully');

                // Load saved layout or use default
                const savedLayout = localStorage.getItem('dashboardLayout');
                if (savedLayout) {
                    console.log('Loading saved dashboard layout');
                    loadDashboardLayout(JSON.parse(savedLayout));
                } else {
                    console.log('Creating default dashboard layout');
                    createDefaultDashboard();
                }

                // Save layout on change
                grid.on('change', saveDashboardLayout);

                // Render widgets with current data
                renderDashboardWidgets();
                console.log('Dashboard initialization completed');
            } catch (error) {
                console.error('Failed to initialize dashboard:', error);
            }
        }

        function createDefaultDashboard() {
            // Stats Widget - proper size for stats display
            const statsWidget = createWidget('stats', 'Statistics', '📊', {
                x: 0, y: 0, w: 12, h: 3,
                minW: 4, minH: 3, maxH: 4
            });

            // Hosts Overview Widget
            const hostsWidget = createWidget('hosts', 'Hosts Overview', '🖥️', {
                x: 0, y: 3, w: 12, h: 8,
                minW: 3, minH: 3
            });

            // Use setTimeout to ensure widgets are fully created before rendering
            setTimeout(() => renderDashboardWidgets(), 50);
        }

        function createWidget(id, title, icon, gridOptions) {
            const widgetHtml = `
                <div class="grid-stack-item" data-widget-id="${id}" gs-x="${gridOptions.x}" gs-y="${gridOptions.y}"
                     gs-w="${gridOptions.w}" gs-h="${gridOptions.h}"
                     gs-min-w="${gridOptions.minW || 2}" gs-min-h="${gridOptions.minH || 2}"
                     ${gridOptions.maxH ? `gs-max-h="${gridOptions.maxH}"` : ''}>
                    <div class="grid-stack-item-content">
                        <div class="widget-header">
                            <div class="widget-title">
                                <span>${icon}</span>
                                <span>${title}</span>
                            </div>
                            <div class="widget-actions">
                                <button class="widget-action lock-btn" onclick="toggleWidgetLock(this)" title="Lock widget">
                                    🔓
                                </button>
                                <button class="widget-action" onclick="removeWidget('${id}')" title="Remove widget">
                                    ✕
                                </button>
                            </div>
                        </div>
                        <div class="widget-body" id="widget-${id}">
                            <!-- Content will be rendered here -->
                        </div>
                    </div>
                </div>
            `;

            grid.addWidget(widgetHtml);
            return document.querySelector(`[data-widget-id="${id}"]`);
        }

        function renderDashboardWidgets() {
            console.log('Rendering dashboard widgets - hosts:', hosts.length, 'containers:', containers.length);

            // Render stats widget - fix: target the widget body, not the whole widget
            const statsWidget = document.getElementById('widget-stats');
            if (statsWidget) {
                statsWidget.innerHTML = `
                    <div class="stats-grid">
                        <div class="stat-card">
                            <div class="stat-icon">🖥️</div>
                            <div class="stat-value">${hosts.length}</div>
                            <div class="stat-label">Total Hosts</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-icon">📦</div>
                            <div class="stat-value">${containers.length}</div>
                            <div class="stat-label">Total Containers</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-icon">✅</div>
                            <div class="stat-value">${containers.filter(c => c.state === 'running').length}</div>
                            <div class="stat-label">Running</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-icon">⚡</div>
                            <div class="stat-value">${alertRules.length}</div>
                            <div class="stat-label">Alert Rules</div>
                        </div>
                    </div>
                `;
            }

            // Render hosts widget
            const hostsWidget = document.getElementById('widget-hosts');
            if (hostsWidget) {
                hostsWidget.className = 'widget-hosts';

                const containersByHost = {};
                containers.forEach(container => {
                    if (!containersByHost[container.host_id]) {
                        containersByHost[container.host_id] = [];
                    }
                    containersByHost[container.host_id].push(container);
                });

                hostsWidget.innerHTML = '<div class="hosts-grid">';

                hosts.forEach(host => {
                    const hostContainers = (containersByHost[host.id] || []).sort((a, b) => a.name.localeCompare(b.name));
                    const maxContainersToShow = hostsWidget.closest('.grid-stack-item').getAttribute('gs-h') > 4 ? 8 : 4;
                    const containersList = hostContainers.slice(0, maxContainersToShow).map(container => `
                        <div class="container-item">
                            <div class="container-info" onclick="showContainerDetails('${container.short_id}')">
                                <div class="container-icon container-${container.state}">
                                    ${getContainerIcon(container.state)}
                                </div>
                                <div class="container-details">
                                    <div class="container-name">${container.name}</div>
                                    <div class="container-id">${container.short_id}</div>
                                </div>
                            </div>
                            <div class="container-actions">
                                <div class="auto-restart-toggle ${container.auto_restart ? 'enabled' : ''}"
                                     onclick="event.stopPropagation()">
                                    <span>🔄</span>
                                    <div class="toggle-switch ${container.auto_restart ? 'active' : ''}"
                                         onclick="toggleAutoRestart('${container.host_id}', '${container.short_id}', event)"></div>
                                </div>
                                <span class="container-state ${getStateClass(container.state)}">
                                    ${container.state}
                                </span>
                            </div>
                        </div>
                    `).join('');

                    const moreCount = hostContainers.length > maxContainersToShow ? hostContainers.length - maxContainersToShow : 0;

                    hostsWidget.innerHTML += `
                        <div class="host-card">
                            <div class="host-header">
                                <div class="host-name">
                                    <span>🖥️</span> ${host.name}
                                </div>
                                <span class="host-status status-${host.status}">${host.status}</span>
                            </div>
                            <div class="container-list">
                                ${containersList || '<div style="padding: 12px; color: var(--text-tertiary); text-align: center;">No containers</div>'}
                                ${moreCount > 0 ? `<div style="padding: 8px 12px; font-size: 12px; color: var(--text-tertiary); text-align: center; border-top: 1px solid var(--border);">+${moreCount} more containers</div>` : ''}
                            </div>
                        </div>
                    `;
                });

                hostsWidget.innerHTML += '</div>';
            }
        }

        function toggleDashboardLock() {
            dashboardLocked = !dashboardLocked;
            grid.setStatic(dashboardLocked);

            const btn = document.getElementById('dashboardLockBtn');
            const icon = document.getElementById('lockBtnIcon');
            const text = document.getElementById('lockBtnText');

            if (dashboardLocked) {
                icon.textContent = '🔒';
                text.textContent = 'Unlock Dashboard';
                document.querySelectorAll('.lock-btn').forEach(btn => {
                    btn.textContent = '🔒';
                    btn.classList.add('locked');
                });
            } else {
                icon.textContent = '🔓';
                text.textContent = 'Lock Dashboard';
                document.querySelectorAll('.lock-btn').forEach(btn => {
                    btn.textContent = '🔓';
                    btn.classList.remove('locked');
                });
            }
        }

        function toggleWidgetLock(btn) {
            const widget = btn.closest('.grid-stack-item');
            const isLocked = widget.classList.contains('gs-locked');

            if (isLocked) {
                grid.movable(widget, true);
                grid.resizable(widget, true);
                widget.classList.remove('gs-locked');
                btn.textContent = '🔓';
                btn.classList.remove('locked');
            } else {
                grid.movable(widget, false);
                grid.resizable(widget, false);
                widget.classList.add('gs-locked');
                btn.textContent = '🔒';
                btn.classList.add('locked');
            }
        }

        function removeWidget(id) {
            const widget = document.querySelector(`[data-widget-id="${id}"]`);
            if (widget) {
                grid.removeWidget(widget);
                saveDashboardLayout();
            }
        }

        function saveDashboardLayout() {
            const items = grid.getGridItems();
            const layout = items.map(item => ({
                id: item.getAttribute('data-widget-id'),
                x: parseInt(item.getAttribute('gs-x')),
                y: parseInt(item.getAttribute('gs-y')),
                w: parseInt(item.getAttribute('gs-w')),
                h: parseInt(item.getAttribute('gs-h'))
            }));
            localStorage.setItem('dashboardLayout', JSON.stringify(layout));
        }

        function loadDashboardLayout(layout) {
            layout.forEach(item => {
                const widgetConfig = getWidgetConfig(item.id);
                if (widgetConfig) {
                    createWidget(widgetConfig.id, widgetConfig.title, widgetConfig.icon, {
                        x: item.x,
                        y: item.y,
                        w: item.w,
                        h: item.h,
                        minW: widgetConfig.minW,
                        minH: widgetConfig.minH,
                        maxH: widgetConfig.maxH
                    });
                }
            });
            // Use setTimeout to ensure widgets are fully created before rendering
            setTimeout(() => renderDashboardWidgets(), 50);
        }

        function getWidgetConfig(id) {
            const configs = {
                'stats': { id: 'stats', title: 'Statistics', icon: '📊', minW: 4, minH: 3, maxH: 4 },
                'hosts': { id: 'hosts', title: 'Hosts Overview', icon: '🖥️', minW: 3, minH: 3 }
            };
            return configs[id];
        }

        function resetDashboardLayout() {
            localStorage.removeItem('dashboardLayout');
            grid.removeAll();
            createDefaultDashboard();
            showToast('Dashboard layout reset to default');
        }


        // Initialize on load
        window.addEventListener('DOMContentLoaded', async () => {
            try {
                await init();
                // Dashboard will be initialized when WebSocket data arrives
                // or when user navigates to dashboard page
            } catch (error) {
                console.error('Failed to initialize application:', error);
                // Don't show error toast - WebSocket will handle data delivery
            }
        });
    </script>

    <!-- GridStack.js Scripts -->
    <script src="https://cdn.jsdelivr.net/npm/gridstack@10.0.1/dist/gridstack-all.js"></script>
</body>
</html>