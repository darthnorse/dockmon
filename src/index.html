<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DockMon</title>
    <link rel="icon" type="image/x-icon" href="/favicon.ico">
    <!-- GridStack.js CSS -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gridstack@10.0.1/dist/gridstack.min.css">
    <style>
        :root {
            /* Modern color scheme */
            --primary: #0084F4;
            --primary-dark: #0066CC;
            --primary-light: #E8F4FD;
            --success: #00C48C;
            --warning: #FFA26B;
            --danger: #FF647C;
            --dark: #1A1D29;
            --dark-secondary: #252837;
            --dark-tertiary: #2D3142;
            --text-primary: #FFFFFF;
            --text-secondary: #A0A3BD;
            --text-tertiary: #6E7191;
            --border: #353849;
            --surface: #1E2139;
            --surface-light: #262A41;
            --background: #161821;
            
            /* Spacing */
            --spacing-xs: 4px;
            --spacing-sm: 8px;
            --spacing-md: 16px;
            --spacing-lg: 24px;
            --spacing-xl: 32px;
            --spacing-2xl: 48px;
            
            /* Transitions */
            --transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', sans-serif;
            background: var(--background);
            color: var(--text-primary);
            line-height: 1.6;
            overflow-x: hidden;
        }

        /* Layout */
        .app-layout {
            display: flex;
            height: 100vh;
        }

        /* Sidebar */
        .sidebar {
            width: 260px;
            background: var(--dark);
            border-right: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            transition: var(--transition);
            z-index: 100;
        }

        .sidebar-header {
            padding: var(--spacing-lg);
            border-bottom: 1px solid var(--border);
            display: flex;
            align-items: center;
            gap: var(--spacing-md);
        }

        .logo {
            width: 36px;
            height: 36px;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .logo img {
            width: 32px;
            height: 32px;
            border-radius: 6px;
        }

        .logo-text {
            font-size: 18px;
            font-weight: 600;
            color: var(--text-primary);
        }

        .sidebar-nav {
            flex: 1;
            padding: var(--spacing-lg) 0;
            overflow-y: auto;
        }

        .nav-section {
            margin-bottom: var(--spacing-xl);
        }

        .nav-section-title {
            padding: 0 var(--spacing-lg);
            margin-bottom: var(--spacing-sm);
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: var(--text-tertiary);
        }

        .nav-item {
            display: flex;
            align-items: center;
            gap: var(--spacing-md);
            padding: var(--spacing-md) var(--spacing-lg);
            color: var(--text-secondary);
            text-decoration: none;
            transition: var(--transition);
            cursor: pointer;
            border: none;
            background: none;
            width: 100%;
            font-size: 14px;
            position: relative;
        }

        .nav-item::before {
            content: '';
            position: absolute;
            left: 0;
            top: 0;
            bottom: 0;
            width: 3px;
            background: var(--primary);
            opacity: 0;
            transition: var(--transition);
        }

        .nav-item:hover {
            background: var(--surface);
            color: var(--text-primary);
        }

        .nav-item.active {
            background: var(--surface);
            color: var(--primary);
        }

        .nav-item.active::before {
            opacity: 1;
        }

        .nav-icon {
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
        }

        .nav-badge {
            margin-left: auto;
            padding: 2px 8px;
            background: var(--primary);
            color: white;
            border-radius: 10px;
            font-size: 11px;
            font-weight: 600;
        }

        /* Sidebar footer */
        .sidebar-footer {
            margin-top: auto;
            padding: var(--spacing-md);
            border-top: 1px solid var(--border);
        }

        .logout-item {
            color: var(--text-secondary) !important;
            transition: all 0.2s ease;
        }

        .logout-item:hover {
            color: var(--danger) !important;
            background: rgba(220, 53, 69, 0.1) !important;
        }

        /* Main Content */
        .main-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            background: var(--background);
            overflow: hidden;
        }

        /* Top Bar */
        .topbar {
            height: 60px;
            background: var(--dark);
            border-bottom: 1px solid var(--border);
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 var(--spacing-xl);
        }

        .topbar-title {
            font-size: 20px;
            font-weight: 600;
            color: var(--text-primary);
        }

        .topbar-actions {
            display: flex;
            align-items: center;
            gap: var(--spacing-md);
        }

        /* Content Area */
        .content {
            flex: 1;
            padding: var(--spacing-xl);
            overflow-y: auto;
            overflow-x: hidden;
        }

        /* Cards */
        .card {
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: var(--spacing-lg);
            margin-bottom: var(--spacing-lg);
            transition: var(--transition);
        }

        .card:hover {
            border-color: var(--primary);
            box-shadow: 0 4px 12px rgba(0, 132, 244, 0.1);
        }

        .card-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: var(--spacing-lg);
            padding-bottom: var(--spacing-md);
            border-bottom: 1px solid var(--border);
        }

        .card-title {
            font-size: 16px;
            font-weight: 600;
            color: var(--text-primary);
            display: flex;
            align-items: center;
            gap: var(--spacing-sm);
        }

        /* GridStack Overrides */
        .grid-stack {
            margin-bottom: var(--spacing-xl);
        }

        .grid-stack-item-content {
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: 12px;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            height: 100%;
        }

        .grid-stack-item.ui-draggable-dragging .grid-stack-item-content {
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
            opacity: 0.8;
        }

        .grid-stack-item.ui-resizable-resizing .grid-stack-item-content {
            opacity: 0.7;
        }

        .widget-header {
            padding: var(--spacing-md) var(--spacing-lg);
            border-bottom: 1px solid var(--border);
            display: flex;
            align-items: center;
            justify-content: space-between;
            background: var(--dark-secondary);
            cursor: move;
        }

        .widget-title {
            font-size: 14px;
            font-weight: 600;
            color: var(--text-primary);
            display: flex;
            align-items: center;
            gap: var(--spacing-sm);
        }

        .widget-actions {
            display: flex;
            gap: var(--spacing-xs);
        }

        .widget-action {
            width: 24px;
            height: 24px;
            border-radius: 6px;
            background: transparent;
            border: none;
            color: var(--text-secondary);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: var(--transition);
        }

        .widget-action:hover {
            background: var(--surface-light);
            color: var(--text-primary);
        }

        .widget-action.lock-btn.locked {
            color: var(--warning);
        }

        .widget-body {
            flex: 1;
            padding: var(--spacing-lg);
            overflow: auto;
        }

        /* Stats Grid */
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
            gap: var(--spacing-sm);
            height: 100%;
            padding: var(--spacing-sm);
        }

        /* Responsive adjustments */
        .grid-stack-item[gs-w="12"] .stats-grid {
            grid-template-columns: repeat(4, 1fr);
        }

        .grid-stack-item[gs-w="8"] .stats-grid,
        .grid-stack-item[gs-w="9"] .stats-grid,
        .grid-stack-item[gs-w="10"] .stats-grid,
        .grid-stack-item[gs-w="11"] .stats-grid {
            grid-template-columns: repeat(2, 1fr);
        }

        .grid-stack-item[gs-w="4"] .stats-grid,
        .grid-stack-item[gs-w="5"] .stats-grid,
        .grid-stack-item[gs-w="6"] .stats-grid,
        .grid-stack-item[gs-w="7"] .stats-grid {
            grid-template-columns: repeat(2, 1fr);
        }

        .grid-stack-item[gs-w="3"] .stats-grid,
        .grid-stack-item[gs-w="2"] .stats-grid {
            grid-template-columns: 1fr;
        }

        /* Widget-specific styles */
        .widget-hosts .hosts-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
            gap: var(--spacing-md);
        }

        .grid-stack-item[gs-w="3"] .widget-hosts .hosts-grid,
        .grid-stack-item[gs-w="4"] .widget-hosts .hosts-grid,
        .grid-stack-item[gs-w="5"] .widget-hosts .hosts-grid,
        .grid-stack-item[gs-w="6"] .widget-hosts .hosts-grid {
            grid-template-columns: 1fr;
        }

        .grid-stack-item[gs-w="7"] .widget-hosts .hosts-grid,
        .grid-stack-item[gs-w="8"] .widget-hosts .hosts-grid,
        .grid-stack-item[gs-w="9"] .widget-hosts .hosts-grid,
        .grid-stack-item[gs-w="10"] .widget-hosts .hosts-grid,
        .grid-stack-item[gs-w="11"] .widget-hosts .hosts-grid,
        .grid-stack-item[gs-w="12"] .widget-hosts .hosts-grid {
            grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
        }

        /* Compact layout for smaller widgets */
        .grid-stack-item[gs-h="2"] .widget-hosts .container-list {
            max-height: 60px;
            overflow-y: auto;
        }

        .grid-stack-item[gs-h="3"] .widget-hosts .container-list {
            max-height: 90px;
            overflow-y: auto;
        }

        .grid-stack-item[gs-h="4"] .widget-hosts .container-list {
            max-height: 130px;
            overflow-y: auto;
        }

        /* Make host cards more compact in small widgets */
        .grid-stack-item[gs-w="3"] .host-card,
        .grid-stack-item[gs-w="4"] .host-card {
            padding: var(--spacing-sm);
        }

        .grid-stack-item[gs-w="3"] .host-header,
        .grid-stack-item[gs-w="4"] .host-header {
            margin-bottom: var(--spacing-sm);
        }

        .grid-stack-item[gs-w="3"] .container-item,
        .grid-stack-item[gs-w="4"] .container-item {
            padding: 4px 0;
        }

        /* Ensure stats grid is always visible */
        .grid-stack-item[gs-h="4"] .stats-grid,
        .grid-stack-item[gs-h="5"] .stats-grid,
        .grid-stack-item[gs-h="6"] .stats-grid {
            align-content: center;
            align-items: stretch;
        }

        /* Make stat cards smaller in compact widgets */
        .grid-stack-item[gs-w="4"] .stat-card,
        .grid-stack-item[gs-w="5"] .stat-card {
            min-height: 60px;
            padding: var(--spacing-sm);
        }

        .grid-stack-item[gs-w="4"] .stat-value,
        .grid-stack-item[gs-w="5"] .stat-value {
            font-size: 22px;
        }

        .grid-stack-item[gs-w="4"] .stat-label,
        .grid-stack-item[gs-w="5"] .stat-label {
            font-size: 10px;
            margin-bottom: 4px;
        }

        /* Host card improvements */
        .host-card {
            background: var(--dark-secondary);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: var(--spacing-md);
            transition: var(--transition);
        }

        .host-card:hover {
            border-color: var(--primary);
            background: var(--surface);
        }

        .stat-card {
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: var(--spacing-md);
            position: relative;
            overflow: hidden;
            transition: var(--transition);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            min-height: 80px;
        }

        .stat-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }

        .stat-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 3px;
            background: linear-gradient(90deg, var(--primary), var(--primary-dark));
        }

        .stat-icon {
            width: 40px;
            height: 40px;
            background: var(--primary);
            background: linear-gradient(135deg, var(--primary), var(--primary-dark));
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            margin-bottom: var(--spacing-md);
        }

        .stat-label {
            font-size: 12px;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            font-weight: 500;
            margin-bottom: var(--spacing-xs);
            text-align: center;
        }

        .stat-value {
            font-size: 28px;
            font-weight: 700;
            color: var(--text-primary);
            line-height: 1;
            text-align: center;
        }

        .stat-change {
            position: absolute;
            top: var(--spacing-md);
            right: var(--spacing-md);
            padding: 4px 8px;
            background: var(--success);
            color: white;
            border-radius: 4px;
            font-size: 12px;
            font-weight: 600;
        }

        .stat-change.negative {
            background: var(--danger);
        }

        /* Buttons */
        .btn {
            padding: 10px 20px;
            border-radius: 6px;
            border: none;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: var(--transition);
            display: inline-flex;
            align-items: center;
            gap: var(--spacing-sm);
        }

        .btn-primary {
            background: var(--primary);
            color: white;
        }

        .btn-primary:hover {
            background: var(--primary-dark);
            transform: translateY(-1px);
        }

        .btn-secondary {
            background: var(--surface-light);
            color: var(--text-primary);
            border: 1px solid var(--border);
        }

        .btn-secondary:hover {
            background: var(--dark-tertiary);
            border-color: var(--primary);
        }

        .btn-danger {
            background: var(--danger);
            color: white;
        }

        .btn-danger:hover {
            background: #d32f2f;
            transform: translateY(-1px);
        }

        .btn-success {
            background: var(--success);
            color: white;
        }

        .btn-danger {
            background: var(--danger);
            color: white;
        }

        .btn-icon {
            padding: 8px;
            border-radius: 6px;
            background: var(--surface-light);
            border: 1px solid var(--border);
            cursor: pointer;
            transition: var(--transition);
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .btn-icon:hover {
            background: var(--dark-tertiary);
            border-color: var(--primary);
        }

        /* Host Grid */
        .hosts-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(400px, 1fr));
            gap: var(--spacing-lg);
        }

        .host-card {
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: 8px;
            overflow: hidden;
            transition: var(--transition);
        }

        .host-card:hover {
            border-color: var(--primary);
            box-shadow: 0 4px 12px rgba(0, 132, 244, 0.1);
        }

        .host-header {
            padding: var(--spacing-md) var(--spacing-lg);
            background: var(--surface-light);
            border-bottom: 1px solid var(--border);
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .host-name {
            font-weight: 600;
            color: var(--text-primary);
            display: flex;
            align-items: center;
            gap: var(--spacing-sm);
        }

        .host-status {
            padding: 4px 12px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: 600;
            text-transform: uppercase;
        }

        .status-online {
            background: rgba(0, 196, 140, 0.1);
            color: var(--success);
        }

        .status-offline {
            background: rgba(255, 100, 124, 0.1);
            color: var(--danger);
        }

        .status-starting {
            background: rgba(144, 238, 144, 0.1);
            color: #90ee90;
            font-style: italic;
        }

        .status-stopping {
            background: rgba(255, 165, 0, 0.1);
            color: #ffa500;
            font-style: italic;
        }

        .security-warning {
            color: #ff6b35;
            margin-left: 8px;
            font-size: 14px;
            cursor: help;
        }

        .security-status {
            margin-left: 8px;
            font-size: 12px;
            font-weight: 600;
            padding: 2px 8px;
            border-radius: 12px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .security-status.secure {
            color: var(--success);
            background-color: rgba(34, 197, 94, 0.1);
        }

        .security-status.insecure {
            color: #e67e22;
            background-color: rgba(230, 126, 34, 0.1);
        }

        .security-alert {
            background: linear-gradient(135deg, #ff6b35, #f7931e);
            color: white;
            padding: 12px;
            border-radius: 8px;
            margin-bottom: 15px;
            border-left: 4px solid #e55039;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .security-alert strong {
            font-weight: 600;
        }

        .form-input[name$="-text"] {
            font-family: 'Courier New', monospace;
            font-size: 12px;
            line-height: 1.4;
            resize: vertical;
            min-height: 80px;
        }

        .form-input[name$="-text"]::placeholder {
            font-family: inherit;
            color: var(--text-tertiary);
            opacity: 0.7;
        }

        /* Container List */
        .container-list {
            padding: var(--spacing-md);
        }

        .container-item {
            padding: var(--spacing-md);
            background: var(--dark);
            border-radius: 6px;
            margin-bottom: var(--spacing-sm);
            display: flex;
            align-items: center;
            justify-content: space-between;
            transition: var(--transition);
            cursor: pointer;
        }

        .container-item:hover {
            background: var(--surface-light);
            transform: translateX(4px);
        }

        .container-item:last-child {
            margin-bottom: 0;
        }

        .container-info {
            display: flex;
            align-items: center;
            gap: var(--spacing-md);
            flex: 1;
        }

        .container-icon {
            width: 32px;
            height: 32px;
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
        }

        .container-running {
            background: rgba(0, 196, 140, 0.2);
            color: var(--success);
        }

        .container-stopped {
            background: rgba(255, 100, 124, 0.2);
            color: var(--danger);
        }

        .container-exited {
            background: rgba(255, 100, 124, 0.2);
            color: var(--danger);
        }

        .container-paused {
            background: rgba(255, 162, 107, 0.2);
            color: var(--warning);
        }

        .container-details {
            flex: 1;
        }

        .container-name {
            font-size: 14px;
            font-weight: 500;
            color: var(--text-primary);
            margin-bottom: 2px;
        }

        .container-id {
            font-size: 12px;
            color: var(--text-tertiary);
            font-family: 'Monaco', 'Courier New', monospace;
        }

        .container-actions {
            display: flex;
            align-items: center;
            gap: var(--spacing-md);
        }

        .container-state {
            padding: 4px 10px;
            border-radius: 4px;
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        /* Auto Restart Toggle */
        .auto-restart-toggle {
            display: flex;
            align-items: center;
            gap: var(--spacing-sm);
            padding: 10px 20px;
            background: var(--surface-light);
            border: 1px solid var(--border);
            border-radius: 6px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: var(--transition);
        }

        .auto-restart-toggle.enabled {
            background: rgba(0, 132, 244, 0.1);
            border-color: var(--primary);
            color: var(--primary);
        }

        .toggle-switch {
            position: relative;
            width: 36px;
            height: 20px;
            background: var(--dark-tertiary);
            border-radius: 20px;
            cursor: pointer;
            transition: var(--transition);
        }

        .toggle-switch.active {
            background: var(--primary);
        }

        .toggle-switch::after {
            content: '';
            position: absolute;
            width: 16px;
            height: 16px;
            background: white;
            border-radius: 50%;
            top: 2px;
            left: 2px;
            transition: transform 0.2s ease;
        }

        .toggle-switch.active::after {
            transform: translateX(16px);
        }

        /* Modal */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(5px);
            z-index: 1000;
        }

        .modal.active {
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .modal-content {
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: var(--spacing-xl);
            max-width: 600px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
            animation: modalSlideIn 0.3s ease;
            position: relative;
        }

        .modal-content.resizable {
            resize: both;
            overflow: auto;
            min-width: 400px;
            min-height: 300px;
            max-width: 90vw;
            max-height: 90vh;
        }

        .resize-handle {
            position: absolute;
            bottom: 0;
            right: 0;
            width: 20px;
            height: 20px;
            cursor: nwse-resize;
            opacity: 0.5;
        }

        .resize-handle::after {
            content: '';
            position: absolute;
            bottom: 3px;
            right: 3px;
            width: 5px;
            height: 5px;
            border-right: 2px solid var(--text-tertiary);
            border-bottom: 2px solid var(--text-tertiary);
        }

        @keyframes modalSlideIn {
            from {
                opacity: 0;
                transform: translateY(-30px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: var(--spacing-lg);
            padding-bottom: var(--spacing-md);
            border-bottom: 1px solid var(--border);
        }

        .modal-title {
            font-size: 20px;
            font-weight: 600;
            color: var(--text-primary);
        }

        .modal-close {
            width: 32px;
            height: 32px;
            border-radius: 6px;
            border: 1px solid var(--border);
            background: var(--surface-light);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: var(--transition);
        }

        .modal-close:hover {
            background: var(--danger);
            border-color: var(--danger);
            transform: rotate(90deg);
        }

        /* Tab styles */
        .tab-content {
            animation: fadeIn 0.3s ease;
        }

        .tab-content pre {
            margin: 0;
            white-space: pre-wrap;
            word-break: break-all;
        }

        #container-logs {
            scrollbar-width: thin;
            scrollbar-color: var(--border) var(--dark);
        }

        #container-logs::-webkit-scrollbar {
            width: 8px;
        }

        #container-logs::-webkit-scrollbar-track {
            background: var(--dark);
        }

        #container-logs::-webkit-scrollbar-thumb {
            background: var(--border);
            border-radius: 4px;
        }

        #container-logs::-webkit-scrollbar-thumb:hover {
            background: var(--primary);
        }

        /* Form Elements */
        .form-group {
            margin-bottom: var(--spacing-lg);
        }

        .form-label {
            display: block;
            margin-bottom: var(--spacing-sm);
            font-size: 14px;
            font-weight: 500;
            color: var(--text-secondary);
        }

        .form-input {
            width: 100%;
            padding: 10px 14px;
            background: var(--dark);
            border: 1px solid var(--border);
            border-radius: 6px;
            color: var(--text-primary);
            font-size: 14px;
            transition: var(--transition);
        }

        .form-input:focus {
            outline: none;
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(0, 132, 244, 0.1);
        }

        .checkbox-group {
            display: flex;
            flex-wrap: wrap;
            gap: var(--spacing-md);
            padding: var(--spacing-md);
            background: var(--dark);
            border-radius: 6px;
        }

        .checkbox-item {
            display: flex;
            align-items: center;
            gap: var(--spacing-sm);
            color: var(--text-secondary);
        }

        .checkbox-item input[type="checkbox"] {
            width: 18px;
            height: 18px;
            cursor: pointer;
        }

        /* Settings Section */
        .settings-section {
            background: var(--dark);
            padding: var(--spacing-lg);
            border-radius: 8px;
            margin-bottom: var(--spacing-lg);
        }

        .settings-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: var(--spacing-md) 0;
            border-bottom: 1px solid var(--border);
        }

        .settings-row:last-child {
            border-bottom: none;
        }

        .settings-label {
            display: flex;
            flex-direction: column;
            gap: var(--spacing-xs);
        }

        .settings-title {
            font-weight: 500;
            color: var(--text-primary);
        }

        .settings-description {
            font-size: 12px;
            color: var(--text-tertiary);
        }

        .settings-value {
            display: flex;
            align-items: center;
            gap: var(--spacing-md);
        }

        .number-input {
            width: 80px;
            padding: 8px 12px;
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: 6px;
            color: var(--text-primary);
            text-align: center;
            font-size: 14px;
            font-weight: 500;
            transition: var(--transition);
        }

        .number-input:focus {
            outline: none;
            border-color: var(--primary);
        }

        /* Logout Button */
        .logout-button {
            position: fixed;
            bottom: 20px;
            left: 20px;
            background: var(--danger);
            color: white;
            border: none;
            padding: 12px 18px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.3s ease;
            z-index: 1000;
            display: flex;
            align-items: center;
            gap: 8px;
            box-shadow: 0 4px 12px rgba(220, 53, 69, 0.3);
        }

        .logout-button:hover {
            background: #c82333;
            transform: translateY(-2px);
            box-shadow: 0 6px 16px rgba(220, 53, 69, 0.4);
        }

        .logout-button:active {
            transform: translateY(0);
        }

        /* Hide logout button when sidebar is open on mobile */
        @media (max-width: 768px) {
            .sidebar-open .logout-button {
                display: none;
            }
        }

        /* Alert Rules */
        .alert-rule-card {
            background: var(--dark);
            padding: var(--spacing-md);
            border-radius: 8px;
            margin-bottom: var(--spacing-md);
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: var(--transition);
        }

        .alert-rule-card:hover {
            background: var(--surface-light);
        }

        .alert-rule-info {
            flex: 1;
        }

        .alert-rule-title {
            font-weight: 500;
            color: var(--text-primary);
            margin-bottom: var(--spacing-xs);
        }

        .alert-rule-details {
            font-size: 13px;
            color: var(--text-tertiary);
        }

        .alert-channels {
            display: flex;
            gap: var(--spacing-sm);
            margin-top: var(--spacing-sm);
        }

        .alert-rule-actions {
            display: flex;
            gap: var(--spacing-xs);
        }

        .channel-badge {
            padding: 2px 8px;
            border-radius: 4px;
            font-size: 11px;
            font-weight: 600;
        }

        .channel-telegram {
            background: rgba(0, 136, 204, 0.2);
            color: #0088cc;
        }

        .channel-discord {
            background: rgba(88, 101, 242, 0.2);
            color: #5865F2;
        }

        .channel-pushover {
            background: rgba(79, 195, 247, 0.2);
            color: #4FC3F7;
        }

        /* Toast */
        .toast {
            position: fixed;
            bottom: var(--spacing-xl);
            right: var(--spacing-xl);
            background: var(--surface-light);
            border: 1px solid var(--border);
            color: var(--text-primary);
            padding: var(--spacing-md) var(--spacing-lg);
            border-radius: 6px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            z-index: 2000;
            display: none;
            animation: toastSlideIn 0.3s ease;
        }

        .toast.show {
            display: block;
        }

        @keyframes toastSlideIn {
            from {
                opacity: 0;
                transform: translateX(100px);
            }
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }

        /* Responsive */
        @media (max-width: 768px) {
            .sidebar {
                width: 60px;
            }

            .sidebar-header .logo-text,
            .nav-item span:not(.nav-icon),
            .nav-badge,
            .nav-section-title {
                display: none;
            }

            .hosts-grid {
                grid-template-columns: 1fr;
            }

            .stats-grid {
                grid-template-columns: 1fr;
            }
        }

        /* Page Sections */
        .page-section {
            display: none;
        }

        .page-section.active {
            display: block;
            animation: fadeIn 0.3s ease;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        /* Mobile Menu Toggle */
        .menu-toggle {
            display: none;
            padding: 8px;
            background: var(--surface-light);
            border: 1px solid var(--border);
            border-radius: 6px;
            cursor: pointer;
        }

        @media (max-width: 768px) {
            .menu-toggle {
                display: flex;
            }
        }
    </style>
</head>
<body>
    <div class="app-layout">
        <!-- Sidebar -->
        <aside class="sidebar">
            <div class="sidebar-header">
                <div class="logo">
                    <img src="/images/logo.png" alt="DockMon Logo">
                </div>
                <div class="logo-text">DockMon</div>
            </div>
            <nav class="sidebar-nav">
                <div class="nav-section">
                    <div class="nav-section-title">Main</div>
                    <a class="nav-item active" onclick="switchPage('dashboard')">
                        <span class="nav-icon">üìä</span>
                        <span>Dashboard</span>
                    </a>
                    <a class="nav-item" onclick="switchPage('hosts')">
                        <span class="nav-icon">üñ•Ô∏è</span>
                        <span>Host Management</span>
                    </a>
                    <a class="nav-item" onclick="switchPage('alerts')">
                        <span class="nav-icon">‚ö°</span>
                        <span>Alert Rules</span>
                    </a>
                </div>
                <div class="nav-section">
                    <div class="nav-section-title">Configuration</div>
                    <a class="nav-item" onclick="openGlobalSettings()">
                        <span class="nav-icon">‚öôÔ∏è</span>
                        <span>Settings</span>
                    </a>
                    <a class="nav-item" onclick="openNotificationSettings()">
                        <span class="nav-icon">üîî</span>
                        <span>Notifications</span>
                    </a>
                </div>
                <div class="nav-section">
                    <div class="nav-section-title">System</div>
                    <a class="nav-item" onclick="switchPage('logs')">
                        <span class="nav-icon">üìã</span>
                        <span>Logs</span>
                    </a>
                    <a class="nav-item" onclick="switchPage('about')">
                        <span class="nav-icon">‚ÑπÔ∏è</span>
                        <span>About</span>
                    </a>
                </div>
            </nav>

            <!-- Logout at bottom of sidebar -->
            <div class="sidebar-footer">
                <a class="nav-item logout-item" onclick="logout()">
                    <span class="nav-icon">üö™</span>
                    <span>Logout</span>
                </a>
            </div>
        </aside>

        <!-- Main Content -->
        <main class="main-content">
            <!-- Top Bar -->
            <header class="topbar">
                <button class="menu-toggle" onclick="toggleSidebar()">‚ò∞</button>
                <h1 class="topbar-title" id="pageTitle">Dashboard</h1>
                <div class="topbar-actions">
                    <button class="btn btn-secondary" onclick="openAccountSettings()" title="Account Settings">
                        <span>üë§</span> <span id="topbarUsername">Account</span>
                    </button>
                    <button class="btn btn-secondary" onclick="refreshAll()">
                        <span>üîÑ</span> Refresh
                    </button>
                    <button class="btn btn-primary" onclick="openHostModal()">
                        <span>‚ûï</span> Add Host
                    </button>
                </div>
            </header>

            <!-- Content Area -->
            <div class="content">
                <!-- Dashboard Page -->
                <div id="dashboard-page" class="page-section active">
                    <!-- Dashboard Actions -->
                    <div style="margin-bottom: var(--spacing-lg); display: flex; gap: var(--spacing-md);">
                        <button class="btn btn-secondary" onclick="toggleDashboardLock()" id="dashboardLockBtn">
                            <span id="lockBtnIcon">üîì</span> <span id="lockBtnText">Lock Layout</span>
                        </button>
                        <button class="btn btn-secondary" onclick="resetDashboardLayout()">
                            üîÑ Reset Layout
                        </button>
                    </div>

                    <!-- GridStack Container -->
                    <div class="grid-stack" id="dashboard-grid">
                        <!-- Widgets will be dynamically added here -->
                    </div>
                </div>

                <!-- Hosts Management Page -->
                <div id="hosts-page" class="page-section">
                    <div class="card">
                        <div class="card-header">
                            <h2 class="card-title">
                                <span>üñ•Ô∏è</span> Docker Hosts
                            </h2>
                            <button class="btn btn-primary" onclick="openHostModal()">
                                Add New Host
                            </button>
                        </div>
                        <div id="hostsList">
                            <!-- Hosts list will be rendered here -->
                        </div>
                    </div>
                </div>

                <!-- Alert Rules Page -->
                <div id="alerts-page" class="page-section">
                    <div class="card">
                        <div class="card-header">
                            <h2 class="card-title">
                                <span>‚ö°</span> Alert Rules
                            </h2>
                            <button class="btn btn-primary" onclick="openAlertRuleModal()">
                                Create Rule
                            </button>
                        </div>
                        <div id="alertRulesList">
                            <!-- Alert rules will be rendered here -->
                        </div>
                    </div>
                </div>

                <!-- Logs Page -->
                <div id="logs-page" class="page-section">
                    <div class="card">
                        <div class="card-header">
                            <h2 class="card-title">
                                <span>üìã</span> System Logs
                            </h2>
                        </div>
                        <div style="padding: var(--spacing-lg); text-align: center; color: var(--text-tertiary);">
                            <p>Log viewer coming soon...</p>
                        </div>
                    </div>
                </div>

                <!-- About Page -->
                <div id="about-page" class="page-section">
                    <div class="card">
                        <div class="card-header">
                            <h2 class="card-title">
                                <span>‚ÑπÔ∏è</span> About
                            </h2>
                        </div>
                        <div style="padding: var(--spacing-lg); color: var(--text-secondary);">
                            <p><strong>Docker Monitor v1.0.0</strong></p>
                            <p style="margin-top: var(--spacing-md);">A modern web-based Docker container monitoring solution with real-time alerts and auto-restart capabilities.</p>
                            <p style="margin-top: var(--spacing-md);">Features:</p>
                            <ul style="margin-left: var(--spacing-lg); margin-top: var(--spacing-sm);">
                                <li>Multi-host Docker monitoring</li>
                                <li>Container auto-restart with configurable retries</li>
                                <li>Multi-channel alerting (Telegram, Discord, Pushover)</li>
                                <li>Real-time status updates</li>
                                <li>Modern, responsive interface</li>
                            </ul>
                            <p style="margin-top: var(--spacing-lg);">
                                <strong>Source Code:</strong>
                                <a href="https://github.com/darthnorse/dockmon" target="_blank" style="color: var(--accent-color); text-decoration: none;">
                                    GitHub Repository
                                </a>
                            </p>
                        </div>
                    </div>
                </div>
            </div>
        </main>
    </div>

    <!-- Modals -->
    <!-- Add Host Modal -->
    <div class="modal" id="hostModal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 class="modal-title">Add Docker Host</h2>
                <button class="modal-close" onclick="closeModal('hostModal')">‚úï</button>
            </div>
            <form onsubmit="addHost(event)">
                <div class="security-alert" id="security-warning" style="display: none;">
                    <span>‚ö†Ô∏è</span>
                    <div>
                        <strong>Security Warning:</strong> This connection is not encrypted! Anyone on the network can take control of your Docker host.
                        <a href="https://github.com/darthnorse/dockmon#-security-mtls-configuration-strongly-recommended" target="_blank" style="color: white; text-decoration: underline;">Learn how to set up mTLS</a>
                    </div>
                </div>

                <div class="form-group">
                    <label class="form-label">Host Name</label>
                    <input type="text" name="hostname" class="form-input" placeholder="Production Server" required>
                </div>
                <div class="form-group">
                    <label class="form-label">Host URL</label>
                    <input type="text" name="hosturl" class="form-input" placeholder="tcp://192.168.1.100:2376" required
                           onchange="checkHostSecurity(this.value)" oninput="checkHostSecurity(this.value)">
                    <small style="color: var(--text-tertiary);">
                        Examples: <code>unix:///var/run/docker.sock</code> (local), <code>tcp://host:2376</code> (remote with mTLS)
                    </small>
                </div>

                <div class="form-group" id="tls-certificates" style="display: none;">
                    <label class="form-label">TLS Certificates (Required for secure remote connections)</label>

                    <!-- Certificate Input -->
                    <div id="cert-paste-mode" style="display: grid; gap: 10px;">
                        <div>
                            <label style="font-size: 14px; color: var(--text-secondary);">CA Certificate (ca.pem)</label>
                            <textarea name="tlsca-text" class="form-input" placeholder="-----BEGIN CERTIFICATE-----&#10;...paste CA certificate content...&#10;-----END CERTIFICATE-----" rows="4"></textarea>
                        </div>
                        <div>
                            <label style="font-size: 14px; color: var(--text-secondary);">Client Certificate (client-cert.pem)</label>
                            <textarea name="tlscert-text" class="form-input" placeholder="-----BEGIN CERTIFICATE-----&#10;...paste client certificate content...&#10;-----END CERTIFICATE-----" rows="4"></textarea>
                        </div>
                        <div>
                            <label style="font-size: 14px; color: var(--text-secondary);">Client Key (client-key.pem)</label>
                            <textarea name="tlskey-text" class="form-input" placeholder="-----BEGIN PRIVATE KEY-----&#10;...paste client private key content...&#10;-----END PRIVATE KEY-----" rows="4"></textarea>
                        </div>
                    </div>

                    <small style="color: var(--text-tertiary);">
                        Use our <a href="https://github.com/darthnorse/dockmon/blob/main/scripts/setup-docker-mtls.sh" target="_blank">mTLS setup script</a> to generate these certificates.
                    </small>
                </div>
                <button type="submit" class="btn btn-primary" style="width: 100%;">
                    Add Host
                </button>
            </form>
        </div>
    </div>

    <!-- Alert Rule Modal -->
    <div class="modal" id="alertRuleModal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 class="modal-title">Create Alert Rule</h2>
                <button class="modal-close" onclick="closeModal('alertRuleModal')">‚úï</button>
            </div>
            <form onsubmit="createAlertRule(event)">
                <div class="form-group">
                    <label class="form-label">Rule Name</label>
                    <input type="text" class="form-input" id="alertRuleName" placeholder="Enter a name for this alert rule" required>
                </div>
                <div class="form-group">
                    <label class="form-label">Container Selection</label>
                    <div style="margin-bottom: 15px;">
                        <label class="checkbox-item" style="display: flex; align-items: center; gap: 8px; margin-bottom: 10px;">
                            <input type="checkbox" id="selectAllContainers" onchange="toggleAllContainers(this)">
                            <strong>Monitor All Containers (all hosts)</strong>
                        </label>
                    </div>
                    <div id="containerSelectionCheckboxes" style="max-height: 300px; overflow-y: auto; border: 1px solid var(--border); border-radius: 4px; padding: 10px;">
                        <!-- Container checkboxes will be populated here -->
                    </div>
                </div>
                <!-- Docker Events Section -->
                <div class="form-group">
                    <label class="form-label">Docker Events <span style="color: var(--text-tertiary); font-size: 12px; font-weight: normal;">(React to what happens)</span></label>
                    <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 15px; margin-top: 10px;">
                        <div>
                            <h4 style="color: #dc2626; font-size: 14px; margin-bottom: 10px; font-weight: 500;">üö® Critical</h4>
                            <div class="checkbox-group">
                                <label class="checkbox-item" title="Container was killed due to memory limit exceeded">
                                    <input type="checkbox" data-event="oom"> Out of Memory
                                </label>
                                <label class="checkbox-item" title="Container exited with error code (crashed or failed)">
                                    <input type="checkbox" data-event="die-nonzero"> Die (non-zero exit)
                                </label>
                                <label class="checkbox-item" title="Container health check failed - container may still be running">
                                    <input type="checkbox" data-event="health_status:unhealthy"> Health: Unhealthy
                                </label>
                            </div>
                        </div>
                        <div>
                            <h4 style="color: #d97706; font-size: 14px; margin-bottom: 10px; font-weight: 500;">‚ö†Ô∏è Warning</h4>
                            <div class="checkbox-group">
                                <label class="checkbox-item" title="Container was forcefully terminated (SIGKILL)">
                                    <input type="checkbox" data-event="kill"> Killed
                                </label>
                                <label class="checkbox-item" title="Container exited cleanly (exit code 0) but unexpectedly">
                                    <input type="checkbox" data-event="die-zero"> Die (clean exit)
                                </label>
                                <label class="checkbox-item" title="Container restarted multiple times in short period">
                                    <input type="checkbox" data-event="restart-loop"> Restart Loop
                                </label>
                                <label class="checkbox-item" title="Container stuck in 'removing' state for over 2 minutes">
                                    <input type="checkbox" data-event="stuck-removing"> Stuck Removing
                                </label>
                            </div>
                        </div>
                        <div>
                            <h4 style="color: var(--text-secondary); font-size: 14px; margin-bottom: 10px; font-weight: 500;">‚ÑπÔ∏è Info</h4>
                            <div class="checkbox-group">
                                <label class="checkbox-item" title="Container was started successfully">
                                    <input type="checkbox" data-event="start"> Started
                                </label>
                                <label class="checkbox-item" title="Container was stopped gracefully (SIGTERM)">
                                    <input type="checkbox" data-event="stop"> Stopped
                                </label>
                                <label class="checkbox-item" title="Container health check passed">
                                    <input type="checkbox" data-event="health_status:healthy"> Health: Healthy
                                </label>
                                <label class="checkbox-item" title="New container was created from image">
                                    <input type="checkbox" data-event="create"> Created
                                </label>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Docker States Section -->
                <div class="form-group">
                    <label class="form-label">Docker States <span style="color: var(--text-tertiary); font-size: 12px; font-weight: normal;">(React to current status)</span></label>
                    <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 20px; margin-top: 10px;">
                        <div>
                            <h4 style="color: #ef4444; font-size: 14px; margin-bottom: 10px; font-weight: 500;">üî¥ Critical</h4>
                            <div class="checkbox-group">
                                <label class="checkbox-item" title="Container has stopped running (exited with any code)">
                                    <input type="checkbox" checked data-state="exited"> Exited
                                </label>
                                <label class="checkbox-item" title="Container has exited and cannot be restarted">
                                    <input type="checkbox" checked data-state="dead"> Dead
                                </label>
                            </div>
                        </div>
                        <div>
                            <h4 style="color: #d97706; font-size: 14px; margin-bottom: 10px; font-weight: 500;">‚ö†Ô∏è Warning</h4>
                            <div class="checkbox-group">
                                <label class="checkbox-item" title="Container has been paused and is not running">
                                    <input type="checkbox" data-state="paused"> Paused
                                </label>
                                <label class="checkbox-item" title="Container is being removed (deletion in progress)">
                                    <input type="checkbox" data-state="removing"> Removing
                                </label>
                            </div>
                        </div>
                        <div>
                            <h4 style="color: var(--text-secondary); font-size: 14px; margin-bottom: 10px; font-weight: 500;">‚ÑπÔ∏è Info</h4>
                            <div class="checkbox-group">
                                <label class="checkbox-item" title="Container has been created but not started">
                                    <input type="checkbox" data-state="created"> Created
                                </label>
                                <label class="checkbox-item" title="Container is currently running and active">
                                    <input type="checkbox" data-state="running"> Running
                                </label>
                                <label class="checkbox-item" title="Container is in the process of restarting">
                                    <input type="checkbox" data-state="restarting"> Restarting
                                </label>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="form-group">
                    <label class="form-label">Alert Channels</label>
                    <div id="notificationChannelsSection">
                        <p style="color: var(--text-tertiary); font-size: 14px; margin-bottom: 15px;">
                            Configure notification channels first in Settings to enable alerts.
                        </p>
                        <button type="button" class="btn btn-secondary" onclick="openNotificationSettings()">
                            Configure Channels
                        </button>
                    </div>
                </div>
                <div class="form-group">
                    <label class="form-label">Cooldown Period (minutes)</label>
                    <input type="number" class="form-input" id="cooldownMinutes" min="1" max="1440" value="15"
                           placeholder="Minutes between alerts">
                    <small style="color: var(--text-tertiary);">Minimum time between alerts for the same container (default: 15 minutes)</small>
                </div>
                <button type="submit" class="btn btn-primary" style="width: 100%;">
                    Create Alert Rule
                </button>
            </form>
        </div>
    </div>

    <!-- Global Settings Modal -->
    <div class="modal" id="globalSettingsModal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 class="modal-title">Global Settings</h2>
                <button class="modal-close" onclick="closeModal('globalSettingsModal')">‚úï</button>
            </div>
            <div class="settings-section">
                <h3 style="margin-bottom: var(--spacing-lg); color: var(--text-primary);">Auto-Restart Configuration</h3>
                <div class="settings-row">
                    <div class="settings-label">
                        <div class="settings-title">Maximum Retry Attempts</div>
                        <div class="settings-description">Number of times to attempt restarting a container before giving up</div>
                    </div>
                    <div class="settings-value">
                        <input type="number" class="number-input" id="maxRetries" min="0" max="10">
                        <span style="font-size: 14px; color: var(--text-tertiary);">retries</span>
                    </div>
                </div>
                <div class="settings-row">
                    <div class="settings-label">
                        <div class="settings-title">Retry Delay</div>
                        <div class="settings-description">Time to wait between restart attempts</div>
                    </div>
                    <div class="settings-value">
                        <input type="number" class="number-input" id="retryDelay" min="5" max="300">
                        <span style="font-size: 14px; color: var(--text-tertiary);">seconds</span>
                    </div>
                </div>
                <div class="settings-row">
                    <div class="settings-label">
                        <div class="settings-title">Enable Auto-Restart by Default</div>
                        <div class="settings-description">New containers will have auto-restart enabled automatically</div>
                    </div>
                    <div class="settings-value">
                        <div class="toggle-switch" id="defaultAutoRestart" onclick="toggleSwitch(this)"></div>
                    </div>
                </div>
            </div>
            <div class="settings-section">
                <h3 style="margin-bottom: var(--spacing-lg); color: var(--text-primary);">Monitoring Settings</h3>
                <div class="settings-row">
                    <div class="settings-label">
                        <div class="settings-title">Polling Interval</div>
                        <div class="settings-description">How often to check container states</div>
                    </div>
                    <div class="settings-value">
                        <input type="number" class="number-input" id="pollingInterval" min="5" max="60">
                        <span style="font-size: 14px; color: var(--text-tertiary);">seconds</span>
                    </div>
                </div>
                <div class="settings-row">
                    <div class="settings-label">
                        <div class="settings-title">Connection Timeout</div>
                        <div class="settings-description">Maximum time to wait for host response</div>
                    </div>
                    <div class="settings-value">
                        <input type="number" class="number-input" id="connectionTimeout" min="5" max="30">
                        <span style="font-size: 14px; color: var(--text-tertiary);">seconds</span>
                    </div>
                </div>
            </div>
            <button class="btn btn-primary" style="width: 100%;" onclick="saveGlobalSettings()">
                Save Settings
            </button>
        </div>
    </div>

    <!-- Notification Settings Modal -->
    <div class="modal" id="notificationModal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 class="modal-title">Notification Settings</h2>
                <button class="modal-close" onclick="closeModal('notificationModal')">‚úï</button>
            </div>
            <form onsubmit="saveNotificationSettings(event)">
                <div class="form-group">
                    <h3 style="margin-bottom: var(--spacing-md); color: var(--text-primary);">Telegram Configuration</h3>
                    <label class="form-label">Bot Token</label>
                    <input type="text" class="form-input" placeholder="Enter Telegram bot token">
                    <label class="form-label" style="margin-top: var(--spacing-md);">Chat ID</label>
                    <input type="text" class="form-input" placeholder="Enter chat ID">
                </div>
                <div class="form-group">
                    <h3 style="margin-bottom: var(--spacing-md); color: var(--text-primary);">Discord Configuration</h3>
                    <label class="form-label">Webhook URL</label>
                    <input type="text" class="form-input" placeholder="Enter Discord webhook URL">
                </div>
                <div class="form-group">
                    <h3 style="margin-bottom: var(--spacing-md); color: var(--text-primary);">Pushover Configuration</h3>
                    <label class="form-label">App Token</label>
                    <input type="text" class="form-input" placeholder="Enter Pushover app token">
                    <label class="form-label" style="margin-top: var(--spacing-md);">User Key</label>
                    <input type="text" class="form-input" placeholder="Enter user key">
                </div>
                <button type="submit" class="btn btn-primary" style="width: 100%;">
                    Save Settings
                </button>
            </form>
        </div>
    </div>

    <!-- Account Settings Modal -->
    <div class="modal" id="accountModal">
        <div class="modal-content" style="max-width: 500px;">
            <div class="modal-header">
                <h2>Account Settings</h2>
                <button class="modal-close" onclick="closeModal('accountModal')">&times;</button>
            </div>
            <form onsubmit="saveAccountSettings(event)">
                <div class="form-group">
                    <h3 style="margin-bottom: var(--spacing-md); color: var(--text-primary);">Change Username</h3>
                    <label class="form-label">Current Username</label>
                    <input type="text" id="currentUsername" class="form-input" readonly style="background: var(--surface-light); cursor: not-allowed;">
                    <label class="form-label" style="margin-top: var(--spacing-md);">New Username</label>
                    <input type="text" id="newUsername" class="form-input" placeholder="Enter new username" minlength="3" maxlength="50">
                    <small style="color: var(--text-secondary);">Leave blank to keep current username</small>
                </div>

                <div class="form-group">
                    <h3 style="margin-bottom: var(--spacing-md); color: var(--text-primary);">Change Password</h3>
                    <label class="form-label">Current Password</label>
                    <input type="password" id="currentPassword" class="form-input" placeholder="Enter current password" required>
                    <label class="form-label" style="margin-top: var(--spacing-md);">New Password</label>
                    <input type="password" id="newPassword" class="form-input" placeholder="Enter new password" minlength="8">
                    <label class="form-label" style="margin-top: var(--spacing-md);">Confirm New Password</label>
                    <input type="password" id="confirmPassword" class="form-input" placeholder="Confirm new password">
                    <small style="color: var(--text-secondary);">Password must be at least 8 characters long</small>
                </div>

                <div id="accountError" class="alert alert-danger" style="display: none; margin-bottom: var(--spacing-md);"></div>
                <div id="accountSuccess" class="alert alert-success" style="display: none; margin-bottom: var(--spacing-md);"></div>

                <button type="submit" class="btn btn-primary" style="width: 100%;">
                    Update Account
                </button>
            </form>
        </div>
    </div>

    <!-- Container Details Modal -->
    <div class="modal" id="containerModal">
        <div class="modal-content resizable" style="width: 900px; height: 600px;">
            <div class="modal-header" style="cursor: move;">
                <h2 class="modal-title">Container Details</h2>
                <button class="modal-close" onclick="closeModal('containerModal')">‚úï</button>
            </div>
            <div class="resize-handle"></div>
            <div id="containerDetails">
                <!-- Container info will be populated here -->
            </div>
            <div style="margin-top: 20px;">
                <ul style="display: flex; gap: 10px; list-style: none; border-bottom: 1px solid var(--border); margin-bottom: 20px;">
                    <li><button class="btn btn-secondary" onclick="showTab('info')" id="tab-info">Info</button></li>
                    <li><button class="btn btn-secondary" onclick="showTab('logs')" id="tab-logs">Logs</button></li>
                </ul>
                
                <!-- Info Tab -->
                <div id="info-tab" class="tab-content">
                    <div id="container-info-content"></div>
                </div>
                
                <!-- Logs Tab -->
                <div id="logs-tab" class="tab-content" style="display: none;">
                    <div style="display: flex; gap: 10px; margin-bottom: 10px; align-items: center; flex-wrap: wrap;">
                        <button class="btn btn-secondary" onclick="fetchContainerLogs()">Refresh Logs</button>
                        <label style="display: flex; align-items: center; gap: 5px; cursor: pointer;">
                            <input type="checkbox" id="autoRefreshLogs" checked onchange="toggleAutoRefresh()" style="cursor: pointer;">
                            <span>Auto-refresh</span>
                        </label>
                        <label style="display: flex; align-items: center; gap: 5px; cursor: pointer;">
                            <input type="checkbox" id="showTimestamps" onchange="updateLogDisplay()" style="cursor: pointer;">
                            <span>Show timestamps</span>
                        </label>
                        <span style="color: var(--text-secondary);">Lines:</span>
                        <input type="number" id="logTailCount" value="100" min="1" max="1000" style="width: 80px; padding: 8px;" placeholder="Lines">
                        <div style="flex: 1; min-width: 200px; position: relative;">
                            <input type="text" id="logSearchFilter" placeholder="Filter logs..." oninput="updateLogDisplay()"
                                style="width: 100%; padding: 8px 30px 8px 10px; border: 1px solid var(--border); border-radius: 6px; background: var(--surface); color: var(--text-primary);">
                            <span id="logMatchCount" style="position: absolute; right: 10px; top: 50%; transform: translateY(-50%); color: var(--text-secondary); font-size: 12px;"></span>
                        </div>
                        <button class="btn btn-secondary" onclick="clearLogFilter()" title="Clear filter" style="padding: 8px 12px;">&times;</button>
                    </div>
                    <div id="container-logs" style="background: var(--dark); padding: 15px; border-radius: 6px; height: 350px; overflow-y: auto; font-family: 'Monaco', 'Courier New', monospace; font-size: 10px; line-height: 1.4; white-space: pre-wrap; word-break: break-all; resize: vertical; min-height: 200px; max-height: 600px;" onmouseup="saveModalPreferences()">
                        <div style="color: var(--text-tertiary);">Loading logs...</div>
                    </div>
                </div>
                
                <!-- Exec functionality removed for security reasons -->
            </div>
        </div>
    </div>

    <!-- Confirmation Dialog Modal -->
    <div class="modal" id="confirmationModal">
        <div class="modal-content" style="max-width: 500px;">
            <div class="modal-header">
                <h2 class="modal-title" id="confirmationTitle">Confirm Action</h2>
                <button class="modal-close" onclick="closeConfirmation()">‚úï</button>
            </div>
            <div class="modal-body" style="padding: 20px 0;">
                <p id="confirmationMessage" style="margin-bottom: 20px; line-height: 1.5;"></p>
                <div style="display: flex; gap: 10px; justify-content: flex-end;">
                    <button class="btn btn-secondary" onclick="closeConfirmation()">Cancel</button>
                    <button class="btn" id="confirmationButton" style="background: var(--danger); border-color: var(--danger);" onclick="confirmAction()">Delete</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Toast Notification -->
    <div class="toast" id="toast"></div>

    <script>
        console.log('DockMon JavaScript loaded');
        // Global state
        let currentPage = 'dashboard';
        let globalSettings = {
            maxRetries: 3,
            retryDelay: 30,
            defaultAutoRestart: false,
            pollingInterval: 10,
            connectionTimeout: 10
        };

        let hosts = [];
        let containers = [];
        let alertRules = [];
        let ws = null;
        let reconnectInterval = null;

        // Auto-restart notification batching
        let restartNotificationBatch = [];
        let restartNotificationTimer = null;
        let editingAlertRule = null; // Track which rule is being edited
        let reconnectAttempts = 0;
        let isConnecting = false; // Prevent multiple simultaneous connections
        const MAX_RECONNECT_ATTEMPTS = 10;

        // API Base URL - backend always runs on port 8080
        const API_BASE = '';  // Use same origin - nginx will proxy /api/* to backend
        const WS_URL = `${window.location.protocol === 'https:' ? 'wss:' : 'ws:'}//${window.location.host}/ws`;


        // Get authentication headers for API requests
        function getAuthHeaders() {
            const headers = {
                'Content-Type': 'application/json'
            };
            // Using session cookies for authentication
            return headers;
        }


        // Initialize WebSocket connection
        function connectWebSocket() {
            // Prevent multiple simultaneous connection attempts
            if (isConnecting) {
                console.log('Connection attempt already in progress, skipping...');
                return;
            }

            // Close existing connection if any
            if (ws && ws.readyState !== WebSocket.CLOSED) {
                ws.close();
            }

            console.log('Connecting to WebSocket:', WS_URL);
            isConnecting = true;

            ws = new WebSocket(WS_URL);
            
            ws.onopen = function() {
                console.log('WebSocket connected');
                showToast('‚úÖ Connected to backend');
                reconnectAttempts = 0;
                isConnecting = false;
                if (reconnectInterval) {
                    clearInterval(reconnectInterval);
                    reconnectInterval = null;
                }
            };
            
            ws.onmessage = function(event) {
                const message = JSON.parse(event.data);
                handleWebSocketMessage(message);
            };
            
            ws.onerror = function(error) {
                console.error('WebSocket error:', error);
                showToast('‚ö†Ô∏è Connection error');
                isConnecting = false; // Reset flag on error
            };

            ws.onclose = function() {
                console.log('WebSocket disconnected');
                showToast('üîå Disconnected - attempting to reconnect...');
                isConnecting = false; // Reset flag on close
                attemptReconnect();
            };
        }

        // Handle batched restart notifications
        function handleRestartNotificationBatch() {
            if (restartNotificationBatch.length === 0) return;

            if (restartNotificationBatch.length === 1) {
                showToast(`‚úÖ Successfully restarted ${restartNotificationBatch[0]}`);
            } else {
                const containerNames = restartNotificationBatch.slice(0, 3).join(', ');
                const remaining = restartNotificationBatch.length - 3;
                const message = remaining > 0
                    ? `‚úÖ Successfully restarted ${containerNames} and ${remaining} more`
                    : `‚úÖ Successfully restarted ${containerNames}`;
                showToast(message);
            }

            // Clear the batch
            restartNotificationBatch = [];
            restartNotificationTimer = null;
        }

        // Handle incoming WebSocket messages
        function handleWebSocketMessage(message) {
            console.log('WebSocket message:', message.type);

            switch(message.type) {
                case 'initial_state':
                    hosts = message.data.hosts || [];
                    containers = message.data.containers || [];
                    globalSettings = message.data.settings || globalSettings;
                    alertRules = message.data.alerts || [];
                    console.log('Received initial state - hosts:', hosts.length, 'containers:', containers.length);
                    console.log('Current page:', currentPage, 'Grid exists:', grid !== null);

                    renderAll();

                    // Initialize dashboard if we're on that page
                    if (currentPage === 'dashboard') {
                        if (grid === null) {
                            console.log('Initializing dashboard with WebSocket data...');
                            setTimeout(() => initDashboard(), 100);
                        } else {
                            console.log('Refreshing existing dashboard widgets...');
                            renderDashboardWidgets();
                        }
                    }
                    break;

                case 'containers_update':
                    containers = message.data.containers || [];
                    hosts = message.data.hosts || [];
                    renderAll();

                    // Refresh container modal if open
                    refreshContainerModalIfOpen();
                    break;
                    
                case 'host_added':
                    fetchHosts();
                    showToast('‚úÖ Host added successfully');
                    break;
                    
                case 'auto_restart_success':
                    // Add to batch instead of showing immediate toast
                    restartNotificationBatch.push(message.data.container_name);

                    // Clear any existing timer and set a new one
                    if (restartNotificationTimer) {
                        clearTimeout(restartNotificationTimer);
                    }

                    // Show batched notification after 2 seconds of no new restarts
                    restartNotificationTimer = setTimeout(handleRestartNotificationBatch, 2000);
                    break;
                    
                case 'auto_restart_failed':
                    showToast(`‚ùå Failed to restart ${message.data.container_name} after ${message.data.attempts} attempts`);
                    break;
                    
                case 'container_restarted':
                    showToast(`üîÑ Container restarted`);
                    break;

                case 'docker_event':
                    // Handle Docker events (container start/stop/restart, etc.)
                    // These are real-time events from Docker daemon - no action needed
                    break;

                default:
                    console.log('Unknown message type:', message.type);
            }
        }

        // Attempt to reconnect to WebSocket
        function attemptReconnect() {
            if (reconnectAttempts >= MAX_RECONNECT_ATTEMPTS) {
                showToast('‚ùå Could not reconnect to backend');
                return;
            }

            // Clear any existing reconnect interval
            if (reconnectInterval) {
                clearInterval(reconnectInterval);
                reconnectInterval = null;
            }

            // Use exponential backoff: 2s, 4s, 8s, 16s, then 30s
            const delay = Math.min(2000 * Math.pow(2, reconnectAttempts), 30000);

            console.log(`Will attempt reconnect in ${delay}ms (attempt ${reconnectAttempts + 1}/${MAX_RECONNECT_ATTEMPTS})`);

            setTimeout(() => {
                reconnectAttempts++;
                console.log(`Reconnect attempt ${reconnectAttempts}/${MAX_RECONNECT_ATTEMPTS}`);
                connectWebSocket();
            }, delay);
        }

        // API Functions
        async function fetchHosts() {
            try {
                const response = await fetch(`${API_BASE}/api/hosts`, {
                    headers: getAuthHeaders(),
                    credentials: 'include'
                });
                if (response.ok) {
                    hosts = await response.json();
                    console.log('Fetched hosts:', hosts.length);
                } else {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
            } catch (error) {
                console.error('Error fetching hosts:', error);
                // Don't show toast during initial load, WebSocket will handle it
                if (hosts.length === 0) {
                    console.log('Will wait for WebSocket data...');
                } else {
                    showToast('‚ùå Failed to fetch hosts');
                }
            }
        }

        async function fetchContainers() {
            try {
                const response = await fetch(`${API_BASE}/api/containers`, {
                    headers: getAuthHeaders(),
                    credentials: 'include'
                });
                if (response.ok) {
                    containers = await response.json();
                    console.log('Fetched containers:', containers.length);
                } else {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
            } catch (error) {
                console.error('Error fetching containers:', error);
                // Don't show toast during initial load, WebSocket will handle it
                if (containers.length === 0) {
                    console.log('Will wait for WebSocket data...');
                } else {
                    showToast('‚ùå Failed to fetch containers');
                }
            }
        }

        async function fetchSettings() {
            try {
                const response = await fetch(`${API_BASE}/api/settings`, {
                    credentials: 'include'
                });
                globalSettings = await response.json();
            } catch (error) {
                console.error('Error fetching settings:', error);
            }
        }

        async function fetchAlertRules() {
            try {
                const response = await fetch(`${API_BASE}/api/alerts`, {
                    credentials: 'include'
                });
                if (response.ok) {
                    alertRules = await response.json() || [];
                    renderAlertRules();
                    updateNavBadges();
                } else {
                    console.warn('Failed to fetch alert rules:', response.status);
                    alertRules = [];
                }
            } catch (error) {
                console.error('Error fetching alert rules:', error);
                alertRules = [];
            }
        }

        // Check authentication status
        async function checkAuthentication() {
            console.log('Checking authentication status...');
            try {
                const response = await fetch(`${API_BASE}/api/auth/status`, {
                    credentials: 'include'
                });

                console.log('Auth response status:', response.status);

                if (response.ok) {
                    const data = await response.json();
                    console.log('Auth data:', data);

                    if (!data.authenticated) {
                        console.log('Not authenticated, redirecting to login');
                        // Redirect to login page
                        window.location.href = '/login.html';
                        return false;
                    }

                    // Store user info
                    if (data.username) {
                        currentUserInfo.username = data.username;
                    }

                    // Check if password change is required (from backend)
                    if (data.must_change_password || data.is_first_login) {
                        sessionStorage.setItem('must_change_password', 'true');
                    }

                    console.log('Authentication successful');
                    return true;
                } else {
                    console.log('Auth check returned non-OK status:', response.status);
                }
            } catch (error) {
                console.error('Auth check error:', error);
            }

            console.log('Auth check failed, redirecting to login');
            // If auth check fails, redirect to login
            window.location.href = '/login.html';
            return false;
        }

        // Logout function
        async function logout() {
            try {
                const response = await fetch(`${API_BASE}/api/auth/logout`, {
                    method: 'POST',
                    credentials: 'include'
                });

                if (response.ok) {
                    window.location.href = '/login.html';
                } else {
                    console.error('Logout failed');
                }
            } catch (error) {
                console.error('Logout error:', error);
                // Force redirect even if logout request fails
                window.location.href = '/login.html';
            }
        }

        // Save modal preferences to localStorage
        function saveModalPreferences() {
            const modal = document.querySelector('#containerModal .modal-content');
            if (modal) {
                const preferences = {
                    width: modal.style.width,
                    height: modal.style.height,
                    transform: modal.style.transform,
                    logsHeight: document.getElementById('container-logs')?.style.height
                };
                localStorage.setItem('containerModalPrefs', JSON.stringify(preferences));
            }
        }

        // Load modal preferences from localStorage
        function loadModalPreferences() {
            const saved = localStorage.getItem('containerModalPrefs');
            if (saved) {
                try {
                    const prefs = JSON.parse(saved);
                    const modal = document.querySelector('#containerModal .modal-content');
                    if (modal) {
                        if (prefs.width) modal.style.width = prefs.width;
                        if (prefs.height) modal.style.height = prefs.height;
                        // Reset transform on load (center the modal)
                        modal.style.transform = 'translate(0, 0)';
                    }
                    // Restore logs height will be done when logs tab is shown
                    return prefs;
                } catch (e) {
                    console.error('Failed to load modal preferences:', e);
                }
            }
            return null;
        }

        // Make modal draggable
        function makeModalDraggable(modalId) {
            const modal = document.getElementById(modalId);
            const modalContent = modal.querySelector('.modal-content');
            const header = modalContent.querySelector('.modal-header');

            let isDragging = false;
            let currentX;
            let currentY;
            let initialX;
            let initialY;
            let xOffset = 0;
            let yOffset = 0;

            header.addEventListener('mousedown', dragStart);
            document.addEventListener('mousemove', drag);
            document.addEventListener('mouseup', dragEnd);

            function dragStart(e) {
                if (e.target.classList.contains('modal-close')) return;

                initialX = e.clientX - xOffset;
                initialY = e.clientY - yOffset;

                if (e.target === header || header.contains(e.target)) {
                    isDragging = true;
                }
            }

            function drag(e) {
                if (isDragging) {
                    e.preventDefault();
                    currentX = e.clientX - initialX;
                    currentY = e.clientY - initialY;

                    xOffset = currentX;
                    yOffset = currentY;

                    modalContent.style.transform = `translate(${currentX}px, ${currentY}px)`;
                }
            }

            function dragEnd(e) {
                initialX = currentX;
                initialY = currentY;
                isDragging = false;
                // Save position after dragging
                saveModalPreferences();
            }
        }

        // Initialize
        async function init() {
            console.log('Starting initialization...');

            // Check authentication first
            const isAuthenticated = await checkAuthentication();
            if (!isAuthenticated) {
                return; // Stop initialization if not authenticated
            }


            // First establish WebSocket connection with a small delay
            connectWebSocket();

            // Set up cleanup function for modal close
            window.cleanupLogStream = function() {
                stopAutoRefresh();
            };

            // Give WebSocket a moment to connect, then fetch data as fallback
            await new Promise(resolve => setTimeout(resolve, 1000));

            // Fetch initial data with fallback handling
            console.log('Fetching initial data...');
            const results = await Promise.allSettled([
                fetchHosts(),
                fetchContainers(),
                fetchSettings(),
                fetchAlertRules()
            ]);

            // Check results but don't fail initialization
            results.forEach((result, index) => {
                const names = ['hosts', 'containers', 'settings', 'alertRules'];
                if (result.status === 'rejected') {
                    console.warn(`Failed to fetch ${names[index]}:`, result.reason);
                } else {
                    console.log(`Successfully fetched ${names[index]}`);
                }
            });

            console.log('Rendering initial UI...');
            renderAll();
            console.log('Initialization completed successfully');
        }

        function renderAll() {
            renderHosts();
            renderAlertRules();
            updateStats();
            updateNavBadges();
        }

        // Page switching
        function switchPage(page) {
            // Update active nav item
            document.querySelectorAll('.nav-item').forEach(item => {
                item.classList.remove('active');
            });
            event.currentTarget.classList.add('active');

            // Hide all pages
            document.querySelectorAll('.page-section').forEach(section => {
                section.classList.remove('active');
            });

            // Show selected page
            document.getElementById(`${page}-page`).classList.add('active');
            currentPage = page;

            // Initialize dashboard when switching to it
            if (page === 'dashboard') {
                if (grid === null) {
                    setTimeout(() => initDashboard(), 100); // Delay to ensure DOM is ready
                } else {
                    renderDashboardWidgets(); // Refresh existing widgets
                }
            }

            // Update page title
            const titles = {
                'dashboard': 'Dashboard',
                'hosts': 'Host Management',
                'alerts': 'Alert Rules',
                'logs': 'System Logs',
                'about': 'About'
            };
            document.getElementById('pageTitle').textContent = titles[page] || 'Dashboard';
            
            currentPage = page;
            
            // Render page-specific content
            if (page === 'hosts') {
                renderHostsPage();
            } else if (page === 'alerts') {
                renderAlertsPage();
            }
        }

        // Render functions
        function renderHosts() {
            // If on dashboard page, update widgets
            if (currentPage === 'dashboard') {
                renderDashboardWidgets();
                return;
            }

            const hostsGrid = document.getElementById('hostsGrid');
            if (!hostsGrid) return;
            hostsGrid.innerHTML = '';

            // Group containers by host
            const containersByHost = {};
            hosts.forEach(host => {
                containersByHost[host.id] = [];
            });
            
            containers.forEach(container => {
                if (containersByHost[container.host_id]) {
                    containersByHost[container.host_id].push(container);
                }
            });
            
            hosts.forEach(host => {
                const hostCard = document.createElement('div');
                hostCard.className = 'host-card';
                
                const hostContainers = (containersByHost[host.id] || []).sort((a, b) => a.name.localeCompare(b.name));
                const containersList = hostContainers.map(container => `
                    <div class="container-item">
                        <div class="container-info" onclick="showContainerDetails('${container.short_id}')">
                            <div class="container-icon container-${container.state}">
                                ${getContainerIcon(container.state)}
                            </div>
                            <div class="container-details">
                                <div class="container-name">${container.name}</div>
                                <div class="container-id">${container.short_id}</div>
                            </div>
                        </div>
                        <div class="container-actions">
                            <div class="auto-restart-toggle ${container.auto_restart ? 'enabled' : ''}" 
                                 onclick="event.stopPropagation()">
                                <span>üîÑ Auto</span>
                                <div class="toggle-switch ${container.auto_restart ? 'active' : ''}" 
                                     onclick="toggleAutoRestart('${container.host_id}', '${container.short_id}', event)"></div>
                            </div>
                            <span class="container-state ${getStateClass(container.state)}">
                                ${container.state}
                            </span>
                        </div>
                    </div>
                `).join('');
                
                hostCard.innerHTML = `
                    <div class="host-header">
                        <div class="host-name">
                            <span>üñ•Ô∏è</span> ${host.name}
                            ${getSecurityStatusBadge(host)}
                        </div>
                        <span class="host-status status-${host.status}">${host.status}</span>
                    </div>
                    <div class="container-list">
                        ${containersList || '<div style="padding: 12px; color: var(--text-tertiary); text-align: center;">No containers</div>'}
                    </div>
                `;
                
                hostsGrid.appendChild(hostCard);
            });
        }

        function renderHostsPage() {
            const hostsList = document.getElementById('hostsList');
            hostsList.innerHTML = hosts.map(host => {
                const hostContainers = containers.filter(c => c.host_id === host.id);
                return `
                    <div class="alert-rule-card">
                        <div class="alert-rule-info">
                            <div class="alert-rule-title">${host.name} ${getSecurityStatusBadge(host)}</div>
                            <div class="alert-rule-details">${host.url} ‚Ä¢ ${hostContainers.length} containers</div>
                            <div class="alert-rule-details" style="margin-top: 4px;">
                                Status: <span class="status-${host.status}">${host.status}</span>
                                ${host.error ? `‚Ä¢ Error: ${host.error}` : ''}
                            </div>
                        </div>
                        <div style="display: flex; gap: var(--spacing-sm);">
                            <button class="btn-icon" onclick="editHost('${host.id}')">‚úèÔ∏è</button>
                            <button class="btn-icon" onclick="deleteHost('${host.id}')">üóëÔ∏è</button>
                        </div>
                    </div>
                `;
            }).join('');
        }

        function renderAlertsPage() {
            renderAlertRules();
        }

        function renderAlertRules() {
            try {
                const alertRulesList = document.getElementById('alertRulesList');
                if (!alertRulesList) return;

                alertRulesList.innerHTML = '';

                if (!alertRules || !Array.isArray(alertRules)) {
                    console.warn('alertRules is not an array:', alertRules);
                    return;
                }

                alertRules.forEach(rule => {
                const ruleCard = document.createElement('div');
                ruleCard.className = 'alert-rule-card';

                const channelBadges = (rule.notification_channels || []).map(channel =>
                    `<span class="channel-badge channel-${channel}">${channel}</span>`
                ).join('');

                // Display container information
                let containerInfo = '';
                if (rule.containers && rule.containers.length > 0) {
                    // Group containers by name to count hosts per container
                    const containerHostCount = {};
                    rule.containers.forEach(c => {
                        if (!containerHostCount[c.container_name]) {
                            containerHostCount[c.container_name] = new Set();
                        }
                        containerHostCount[c.container_name].add(c.host_id);
                    });

                    // Build display string showing container names with host counts
                    const containerParts = Object.entries(containerHostCount).map(([name, hosts]) => {
                        if (hosts.size > 1) {
                            return `${name} (${hosts.size} hosts)`;
                        }
                        return name;
                    });

                    containerInfo = containerParts.join(', ');
                } else {
                    containerInfo = 'No containers selected';
                }

                // Display trigger information
                let triggerInfo = [];
                if (rule.trigger_states && rule.trigger_states.length > 0) {
                    triggerInfo.push(`States: ${rule.trigger_states.join(', ')}`);
                }
                if (rule.trigger_events && rule.trigger_events.length > 0) {
                    triggerInfo.push(`Events: ${rule.trigger_events.join(', ')}`);
                }
                const triggerText = triggerInfo.length > 0 ? triggerInfo.join(' | ') : 'No triggers';

                ruleCard.innerHTML = `
                    <div class="alert-rule-info">
                        <div class="alert-rule-title">${rule.name}</div>
                        <div class="alert-rule-details">Containers: ${containerInfo} | ${triggerText}</div>
                        <div class="alert-channels">${channelBadges}</div>
                    </div>
                    <div class="alert-rule-actions">
                        <button class="btn-icon" onclick="editAlertRule('${rule.id}')" title="Edit Alert Rule">
                            ‚úèÔ∏è
                        </button>
                        <button class="btn-icon" onclick="deleteAlertRule('${rule.id}')" title="Delete Alert Rule">
                            üóëÔ∏è
                        </button>
                    </div>
                `;
                
                alertRulesList.appendChild(ruleCard);
                });
            } catch (error) {
                console.error('Error rendering alert rules:', error);
            }
        }

        // Update functions
        function updateStats() {
            // Stats are now handled by dashboard widgets
            // Only update if we're not on the dashboard page (for backward compatibility)
            if (currentPage !== 'dashboard') {
                const totalHostsEl = document.getElementById('totalHosts');
                const totalContainersEl = document.getElementById('totalContainers');
                const runningContainersEl = document.getElementById('runningContainers');
                const alertRulesEl = document.getElementById('alertRules');

                if (totalHostsEl) totalHostsEl.textContent = hosts.length;
                if (totalContainersEl) totalContainersEl.textContent = containers.length;
                if (runningContainersEl) runningContainersEl.textContent = containers.filter(c => c.state === 'running').length;
                if (alertRulesEl) alertRulesEl.textContent = alertRules.length;
            }
        }

        function updateNavBadges() {
            // Navigation badges removed - stats are shown in dashboard widget instead
        }

        // Helper functions
        function getContainerIcon(state) {
            switch(state) {
                case 'running': return '‚ñ∂';
                case 'exited': return '‚ñ†';
                case 'paused': return '‚è∏';
                default: return '?';
            }
        }

        function getStateClass(state) {
            switch(state) {
                case 'running': return 'status-online';
                case 'exited': return 'status-offline';
                case 'paused': return 'channel-pushover';
                default: return '';
            }
        }

        // Modal functions
        function openHostModal() {
            // Reset form for adding new host
            const modalTitle = document.querySelector('#hostModal .modal-title');
            const submitButton = document.querySelector('#hostModal button[type="submit"]');

            modalTitle.textContent = 'Add Docker Host';
            submitButton.textContent = 'Add Host';

            // Clear the form
            document.querySelector('input[name="hostname"]').value = '';
            document.querySelector('input[name="hosturl"]').value = '';

            // Clear editing state
            window.editingHost = null;

            // Hide security warning and certificates
            checkHostSecurity('');

            document.getElementById('hostModal').classList.add('active');
            // Certificate paste mode is already visible
        }

        function checkHostSecurity(url) {
            const securityWarning = document.getElementById('security-warning');
            const tlsCertificates = document.getElementById('tls-certificates');

            // Show warning and certificate fields for TCP connections
            if (url && url.toLowerCase().startsWith('tcp://')) {
                // Check if we're editing an existing secure host
                const isEditingSecureHost = window.editingHost && window.editingHost.security_status === 'secure';

                if (isEditingSecureHost) {
                    // Host is already configured as secure, no warning needed
                    securityWarning.style.display = 'none';
                } else {
                    // New host or insecure host, show warning
                    securityWarning.style.display = 'flex';
                }

                // Always show certificate fields for TCP connections
                tlsCertificates.style.display = 'block';
            } else {
                securityWarning.style.display = 'none';
                tlsCertificates.style.display = 'none';
            }
        }


        async function getCertificateData(formData, certType) {
            // Get from text input (copy/paste mode only)
            const textData = formData.get(`${certType}-text`);
            if (textData && textData.trim()) {
                return textData.trim();
            }
            return null;
        }

        // Removed regex pattern mode - now only using checkbox selection

        function toggleAllContainers(checkbox) {
            const containerCheckboxes = document.querySelectorAll('#containerSelectionCheckboxes input[type="checkbox"]');
            containerCheckboxes.forEach(cb => {
                cb.checked = checkbox.checked;
            });
        }

        function populateContainerCheckboxes() {
            const container = document.getElementById('containerSelectionCheckboxes');
            container.innerHTML = '';

            // Group containers by host
            const containersByHost = {};
            containers.forEach(cont => {
                const hostName = cont.host_name || 'Unknown Host';
                if (!containersByHost[hostName]) {
                    containersByHost[hostName] = [];
                }
                containersByHost[hostName].push(cont);
            });

            // Create checkboxes grouped by host
            Object.keys(containersByHost).sort().forEach(hostName => {
                // Host header
                const hostDiv = document.createElement('div');
                hostDiv.style.marginBottom = '15px';

                const hostHeader = document.createElement('div');
                hostHeader.style.fontWeight = 'bold';
                hostHeader.style.marginBottom = '8px';
                hostHeader.style.color = 'var(--primary)';
                hostHeader.textContent = hostName;
                hostDiv.appendChild(hostHeader);

                // Container checkboxes for this host
                const containersDiv = document.createElement('div');
                containersDiv.style.paddingLeft = '20px';

                containersByHost[hostName].sort((a, b) => a.name.localeCompare(b.name)).forEach(cont => {
                    const label = document.createElement('label');
                    label.className = 'checkbox-item';
                    label.style.display = 'flex';
                    label.style.alignItems = 'center';
                    label.style.gap = '8px';
                    label.style.marginBottom = '5px';

                    const checkbox = document.createElement('input');
                    checkbox.type = 'checkbox';
                    checkbox.value = cont.name;
                    checkbox.dataset.hostId = cont.host_id;
                    checkbox.dataset.containerId = cont.id;

                    const stateIndicator = document.createElement('span');
                    stateIndicator.style.display = 'inline-block';
                    stateIndicator.style.width = '8px';
                    stateIndicator.style.height = '8px';
                    stateIndicator.style.borderRadius = '50%';
                    stateIndicator.style.backgroundColor = cont.state === 'running' ? '#00c48c' : '#ff647c';

                    const text = document.createElement('span');
                    text.textContent = cont.name;

                    label.appendChild(checkbox);
                    label.appendChild(stateIndicator);
                    label.appendChild(text);
                    containersDiv.appendChild(label);
                });

                hostDiv.appendChild(containersDiv);
                container.appendChild(hostDiv);
            });

            // If no containers, show message
            if (Object.keys(containersByHost).length === 0) {
                container.innerHTML = '<p style="color: var(--text-tertiary); text-align: center;">No containers available</p>';
            }
        }

        function openAlertRuleModal(preselectedContainer = null, editRule = null) {
            // Update modal title and button text based on mode
            const modalTitle = document.querySelector('#alertRuleModal .modal-title');
            const submitButton = document.querySelector('#alertRuleModal button[type="submit"]');

            if (editRule) {
                modalTitle.textContent = 'Edit Alert Rule';
                submitButton.textContent = 'Update Alert Rule';
                // Store the rule being edited
                editingAlertRule = editRule;
                // Populate form with existing rule data
                document.getElementById('alertRuleName').value = editRule.name || '';

                // We'll populate other fields after the form is built
                setTimeout(() => {
                    // Select trigger states - handled individually below for better control

                    // Select notification channels
                    if (editRule.notification_channels) {
                        editRule.notification_channels.forEach(channelId => {
                            const checkbox = document.querySelector(`input[value="${channelId}"]`);
                            if (checkbox) checkbox.checked = true;
                        });
                    }

                    // Set cooldown
                    const cooldownInput = document.getElementById('cooldownMinutes');
                    if (cooldownInput && editRule.cooldown_minutes) {
                        cooldownInput.value = editRule.cooldown_minutes;
                    }
                }, 100);
            } else {
                modalTitle.textContent = 'Create Alert Rule';
                submitButton.textContent = 'Create Alert Rule';
                // Clear the form completely
                document.getElementById('alertRuleName').value = '';
                editingAlertRule = null;

                // Clear all checkboxes (events, states, containers, channels)
                document.querySelectorAll('#alertRuleModal input[type="checkbox"]').forEach(cb => cb.checked = false);

                // Set default selections for new alerts
                setTimeout(() => {
                    // Default events: OOM, Die (non-zero), Health: Unhealthy
                    const defaultEvents = ['oom', 'die-nonzero', 'health_status:unhealthy'];
                    defaultEvents.forEach(event => {
                        const checkbox = document.querySelector(`input[type="checkbox"][data-event="${event}"]`);
                        if (checkbox) checkbox.checked = true;
                    });

                    // Default states: Exited, Dead
                    const defaultStates = ['exited', 'dead'];
                    defaultStates.forEach(state => {
                        const checkbox = document.querySelector(`input[type="checkbox"][data-state="${state}"]`);
                        if (checkbox) checkbox.checked = true;
                    });
                }, 50);
            }

            // Populate container checkboxes
            populateContainerCheckboxes();

            // If editing a rule, restore the selected containers
            if (editRule) {
                // First, check if the rule has the new container+host pairs format
                if (editRule.containers && editRule.containers.length > 0) {
                    // New format: use specific container+host pairs
                    document.getElementById('selectAllContainers').checked = false; // Not all containers
                    document.querySelectorAll('#containerSelectionCheckboxes input[type="checkbox"]').forEach(cb => {
                        cb.checked = false; // Clear all first
                    });

                    editRule.containers.forEach(containerPair => {
                        document.querySelectorAll('#containerSelectionCheckboxes input[type="checkbox"]').forEach(cb => {
                            if (cb.value === containerPair.container_name &&
                                cb.dataset.hostId === containerPair.host_id) {
                                cb.checked = true;
                            }
                        });
                    });
                }
            }

            // Pre-select container if one was specified (must match both container name AND host)
            if (preselectedContainer && !editRule) {
                document.querySelectorAll('#containerSelectionCheckboxes input[type="checkbox"]').forEach(cb => {
                    if (cb.value === preselectedContainer.name && cb.dataset.hostId === preselectedContainer.host_id) {
                        cb.checked = true;
                    }
                });
            }

            // Populate notification channels
            populateNotificationChannels();

            // If editing, populate form fields
            if (editRule) {
                // Clear and set trigger checkboxes immediately (no setTimeout needed here)
                // Clear only trigger state and event checkboxes first (not container or notification checkboxes)
                document.querySelectorAll('#alertRuleModal input[type="checkbox"][data-state]').forEach(cb => cb.checked = false);
                document.querySelectorAll('#alertRuleModal input[type="checkbox"][data-event]').forEach(cb => cb.checked = false);

                // Check appropriate boxes based on trigger events
                if (editRule.trigger_events) {
                    editRule.trigger_events.forEach(event => {
                        const checkbox = document.querySelector(`input[type="checkbox"][data-event="${event}"]`);
                        if (checkbox) checkbox.checked = true;
                    });
                }

                // Check appropriate boxes based on trigger states
                if (editRule.trigger_states) {
                    editRule.trigger_states.forEach(state => {
                        const checkbox = document.querySelector(`input[type="checkbox"][data-state="${state}"]`);
                        if (checkbox) checkbox.checked = true;
                    });
                }

                // Set notification channels - with small delay to ensure they're loaded
                setTimeout(() => {
                    if (editRule.notification_channels) {
                        editRule.notification_channels.forEach(channelId => {
                            const channelCheckbox = document.querySelector(`input[type="checkbox"][data-channel-id="${channelId}"]`);
                            if (channelCheckbox) channelCheckbox.checked = true;
                        });
                    }
                }, 100); // Small delay to ensure notification channels are loaded
            }

            document.getElementById('alertRuleModal').classList.add('active');
        }

        async function populateNotificationChannels() {
            try {
                const response = await fetch(`${API_BASE}/api/notifications/channels`, {
                    credentials: 'include'
                });
                const channels = await response.json();

                const channelsSection = document.getElementById('notificationChannelsSection');

                if (channels && channels.length > 0) {
                    // Show available channels as checkboxes
                    let channelsHtml = '<div class="checkbox-group">';
                    channels.forEach(channel => {
                        channelsHtml += `
                            <label class="checkbox-item">
                                <input type="checkbox" name="channels" value="${channel.id}" data-channel-id="${channel.id}">
                                ${channel.name} (${channel.type})
                            </label>
                        `;
                    });
                    channelsHtml += '</div>';

                    channelsSection.innerHTML = channelsHtml;
                } else {
                    // No channels configured yet
                    channelsSection.innerHTML = `
                        <p style="color: var(--text-tertiary); font-size: 14px; margin-bottom: 15px;">
                            No notification channels configured yet. Set up Discord, Telegram, or Pushover to receive alerts.
                        </p>
                        <button type="button" class="btn btn-secondary" onclick="openNotificationSettings()">
                            Configure Channels
                        </button>
                    `;
                }
            } catch (error) {
                console.error('Error fetching notification channels:', error);
                const channelsSection = document.getElementById('notificationChannelsSection');
                channelsSection.innerHTML = `
                    <p style="color: var(--text-tertiary); font-size: 14px; margin-bottom: 15px;">
                        Configure notification channels first in Settings to enable alerts.
                    </p>
                    <button type="button" class="btn btn-secondary" onclick="openNotificationSettings()">
                        Configure Channels
                    </button>
                `;
            }
        }

        async function openNotificationSettings() {
            try {
                await loadNotificationSettings();
                document.getElementById('notificationModal').classList.add('active');
            } catch (error) {
                console.error('Error opening notification settings:', error);
                showToast('Failed to open notification settings', 'error');
            }
        }

        async function loadNotificationSettings() {
            try {
                const response = await fetch(`${API_BASE}/api/notifications/channels`, {
                    credentials: 'include'
                });
                const channels = await response.json();

                // Clear existing values
                document.querySelectorAll('#notificationModal .form-input').forEach(input => {
                    input.value = '';
                });

                // Populate existing settings
                channels.forEach(channel => {
                    if (channel.type === 'telegram') {
                        const tokenInput = document.querySelector('#notificationModal .form-input[placeholder*="Telegram bot token"]');
                        const chatInput = document.querySelector('#notificationModal .form-input[placeholder*="chat ID"]');
                        if (tokenInput && chatInput && channel.config) {
                            tokenInput.value = channel.config.bot_token || '';
                            chatInput.value = channel.config.chat_id || '';
                        }
                    } else if (channel.type === 'discord') {
                        const webhookInput = document.querySelector('#notificationModal .form-input[placeholder*="Discord webhook"]');
                        if (webhookInput && channel.config) {
                            webhookInput.value = channel.config.webhook_url || '';
                        }
                    } else if (channel.type === 'pushover') {
                        const tokenInput = document.querySelector('#notificationModal .form-input[placeholder*="Pushover app token"]');
                        const userInput = document.querySelector('#notificationModal .form-input[placeholder*="user key"]');
                        if (tokenInput && userInput && channel.config) {
                            tokenInput.value = channel.config.app_token || '';
                            userInput.value = channel.config.user_key || '';
                        }
                    }
                });
            } catch (error) {
                console.error('Error loading notification settings:', error);
            }
        }

        function createAlertForContainer(containerId) {
            // Find the container
            const container = containers.find(c => c.id === containerId);
            if (container) {
                // Check if there's an existing alert rule for this container on this specific host
                const existingRule = alertRules.find(rule => {
                    // Check new container+host pairs format first
                    if (rule.containers && rule.containers.length > 0) {
                        return rule.containers.some(c =>
                            c.container_name === container.name && c.host_id === container.host_id
                        );
                    }
                    return false;
                });

                // Close current modal
                closeModal('containerModal');

                if (existingRule) {
                    // Edit existing rule
                    openAlertRuleModal(container, existingRule);
                } else {
                    // Create new rule with container pre-selected
                    openAlertRuleModal(container);
                }
            }
        }

        async function editAlertRule(ruleId) {
            try {
                // Find the rule in the current alertRules array
                const rule = alertRules.find(r => r.id === ruleId);
                if (!rule) {
                    showToast('‚ùå Alert rule not found');
                    return;
                }

                editingAlertRule = rule;
                openAlertRuleModal(null, rule);
            } catch (error) {
                console.error('Error opening alert rule for editing:', error);
                showToast('‚ùå Failed to open alert rule for editing');
            }
        }

        function openGlobalSettings() {
            document.getElementById('maxRetries').value = globalSettings.max_retries;
            document.getElementById('retryDelay').value = globalSettings.retry_delay;
            document.getElementById('pollingInterval').value = globalSettings.polling_interval;
            document.getElementById('connectionTimeout').value = globalSettings.connection_timeout;

            const defaultToggle = document.getElementById('defaultAutoRestart');
            if (globalSettings.default_auto_restart) {
                defaultToggle.classList.add('active');
            } else {
                defaultToggle.classList.remove('active');
            }

            document.getElementById('globalSettingsModal').classList.add('active');
        }

        function getSecurityStatusBadge(host) {
            if (!host.url || host.url.includes('unix://')) {
                return ''; // Local connections don't need security status
            }

            if (host.security_status === 'secure') {
                return '<span class="security-status secure">Secure</span>';
            } else if (host.security_status === 'insecure') {
                return '<span class="security-status insecure">Insecure</span>';
            }
            return ''; // Unknown status - don't show anything
        }

        function closeModal(modalId) {
            if (modalId === 'containerModal') {
                // Save preferences before closing
                saveModalPreferences();

                // Use the cleanup function
                if (window.cleanupLogStream) {
                    window.cleanupLogStream();
                }
                const streamBtn = document.getElementById('streamLogsBtn');
                if (streamBtn) {
                    streamBtn.textContent = 'Start Live Stream';
                }
            }
            document.getElementById(modalId).classList.remove('active');
        }

        // Account Settings Functions
        let currentUserInfo = { username: 'admin' };

        async function getCurrentUser() {
            try {
                const response = await fetch(`${API_BASE}/api/auth/status`, {
                    credentials: 'include'
                });
                if (response.ok) {
                    const data = await response.json();
                    currentUserInfo = data;
                    // Update UI with username
                    const topbarUsername = document.getElementById('topbarUsername');
                    const currentUsernameInput = document.getElementById('currentUsername');

                    if (topbarUsername) topbarUsername.textContent = data.username;
                    if (currentUsernameInput) currentUsernameInput.value = data.username;
                }
            } catch (error) {
                console.error('Error fetching user info:', error);
            }
        }

        function openAccountSettings() {
            getCurrentUser();
            document.getElementById('accountModal').classList.add('active');

            // Clear form
            document.getElementById('newUsername').value = '';
            document.getElementById('newPassword').value = '';
            document.getElementById('confirmPassword').value = '';
            document.getElementById('accountError').style.display = 'none';
            document.getElementById('accountSuccess').style.display = 'none';

            // Check if we have a temporary password from first login
            const tempPassword = sessionStorage.getItem('temp_current_password');
            if (tempPassword) {
                document.getElementById('currentPassword').value = tempPassword;
                // Clear it immediately after use for security
                sessionStorage.removeItem('temp_current_password');
            } else {
                document.getElementById('currentPassword').value = '';
            }
        }

        async function saveAccountSettings(event) {
            event.preventDefault();

            const currentPassword = document.getElementById('currentPassword').value;
            const newUsername = document.getElementById('newUsername').value.trim();
            const newPassword = document.getElementById('newPassword').value;
            const confirmPassword = document.getElementById('confirmPassword').value;
            const errorDiv = document.getElementById('accountError');
            const successDiv = document.getElementById('accountSuccess');

            errorDiv.style.display = 'none';
            successDiv.style.display = 'none';

            // Validate passwords match
            if (newPassword && newPassword !== confirmPassword) {
                errorDiv.textContent = 'New passwords do not match';
                errorDiv.style.display = 'block';
                return;
            }

            // Validate password length
            if (newPassword && newPassword.length < 8) {
                errorDiv.textContent = 'Password must be at least 8 characters long';
                errorDiv.style.display = 'block';
                return;
            }

            try {
                // Change username if provided
                if (newUsername && newUsername !== currentUserInfo.username) {
                    const usernameResponse = await fetch(`${API_BASE}/api/auth/change-username`, {
                        method: 'POST',
                        headers: getAuthHeaders(),
                        credentials: 'include',
                        body: JSON.stringify({
                            current_password: currentPassword,
                            new_username: newUsername
                        })
                    });

                    if (!usernameResponse.ok) {
                        const error = await usernameResponse.json();
                        throw new Error(error.detail || 'Failed to change username');
                    }
                }

                // Change password if provided
                if (newPassword) {
                    const passwordResponse = await fetch(`${API_BASE}/api/auth/change-password`, {
                        method: 'POST',
                        headers: getAuthHeaders(),
                        credentials: 'include',
                        body: JSON.stringify({
                            current_password: currentPassword,
                            new_password: newPassword
                        })
                    });

                    if (!passwordResponse.ok) {
                        const error = await passwordResponse.json();
                        throw new Error(error.detail || 'Failed to change password');
                    }
                }

                successDiv.textContent = 'Account updated successfully';
                successDiv.style.display = 'block';

                // Clear password change requirement
                sessionStorage.removeItem('must_change_password');

                // Update username displays
                await getCurrentUser();

                // Clear form
                setTimeout(() => {
                    closeModal('accountModal');
                }, 1500);

            } catch (error) {
                errorDiv.textContent = error.message;
                errorDiv.style.display = 'block';
            }
        }

        async function logout() {
            try {
                const response = await fetch(`${API_BASE}/api/auth/logout`, {
                    method: 'POST',
                    credentials: 'include'
                });

                if (response.ok) {
                    window.location.href = '/login.html';
                }
            } catch (error) {
                console.error('Logout error:', error);
                showToast('‚ùå Failed to logout');
            }
        }

        function checkPasswordChangeRequired() {
            const mustChange = sessionStorage.getItem('must_change_password');
            if (mustChange === 'true') {
                // Show password change modal
                setTimeout(() => {
                    showToast('‚ö†Ô∏è Please change your default password for security');
                    openAccountSettings();

                    // Add a notice at the top of the form for first login
                    const errorDiv = document.getElementById('accountError');
                    const successDiv = document.getElementById('accountSuccess');
                    errorDiv.style.display = 'block';
                    errorDiv.style.background = 'rgba(255, 193, 7, 0.1)';
                    errorDiv.style.borderColor = 'rgba(255, 193, 7, 0.3)';
                    errorDiv.style.color = '#ffc107';
                    errorDiv.textContent = '‚ö†Ô∏è First login detected. Please change your default password for security.';
                }, 1000);
            }
        }

        // Confirmation modal functions
        let confirmationCallback = null;

        function showConfirmation(title, message, buttonText, callback) {
            document.getElementById('confirmationTitle').textContent = title;
            document.getElementById('confirmationMessage').innerHTML = message;
            document.getElementById('confirmationButton').textContent = buttonText;
            confirmationCallback = callback;
            document.getElementById('confirmationModal').classList.add('active');
        }

        function closeConfirmation() {
            document.getElementById('confirmationModal').classList.remove('active');
            confirmationCallback = null;
        }

        function confirmAction() {
            if (confirmationCallback) {
                confirmationCallback();
            }
            closeConfirmation();
        }

        function refreshContainerModalIfOpen() {
            const containerModal = document.getElementById('containerModal');
            if (containerModal && containerModal.classList.contains('active') && window.currentContainer) {
                // Find the updated container data using the stored container ID
                const updatedContainer = containers.find(c => c.short_id === window.currentContainer.short_id);
                if (updatedContainer) {
                    // Remember which tab is currently active
                    let activeTab = 'info';
                    if (document.getElementById('logs-tab').style.display !== 'none') {
                        activeTab = 'logs';
                    }

                    // Re-populate the modal with updated data (but preserve the tab)
                    showContainerDetails(updatedContainer.short_id, activeTab);
                }
            }
        }

        // Toggle functions
        function toggleSwitch(element) {
            element.classList.toggle('active');
        }

        async function toggleAutoRestart(hostId, containerId, event) {
            event.stopPropagation();

            // Find the container to get current state (must match both container ID and host)
            const container = containers.find(c =>
                (c.short_id === containerId || c.id === containerId) && c.host_id === hostId
            );
            if (!container) {
                console.error('Container not found:', containerId, 'on host:', hostId);
                return;
            }

            const newState = !container.auto_restart;

            try {
                const response = await fetch(`${API_BASE}/api/containers/${container.short_id}/auto-restart`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        host_id: hostId,
                        container_name: container.name,
                        enabled: newState
                    })
                });

                if (response.ok) {
                    // Update local state
                    container.auto_restart = newState;
                    container.restart_attempts = 0;

                    renderHosts();

                    // Update modal content if it's open and showing this container
                    if (window.currentContainer && window.currentContainer.id === container.id) {
                        // Preserve current tab when updating for auto-restart
                        let activeTab = 'info';
                        if (document.getElementById('logs-tab').style.display !== 'none') {
                            activeTab = 'logs';
                        }
                        showContainerDetails(container.short_id, activeTab);
                    }

                    const status = newState ? 'enabled' : 'disabled';
                    showToast(`üîÑ Auto-restart ${status} for ${container.name}`);

                    if (newState && container.state === 'exited') {
                        // Trigger restart attempt
                        restartContainer(hostId, container.id);
                    }
                } else {
                    showToast('‚ùå Failed to toggle auto-restart');
                }
            } catch (error) {
                console.error('Error toggling auto-restart:', error);
                showToast('‚ùå Failed to toggle auto-restart');
            }
        }

        // Actions
        async function addHost(event) {
            event.preventDefault();
            const formData = new FormData(event.target);

            const hostData = {
                name: formData.get('hostname'),
                url: formData.get('hosturl')
            };

            // Handle certificate data from either file upload or text input
            const tlsCertificate = await getCertificateData(formData, 'tlscert');
            const tlsKey = await getCertificateData(formData, 'tlskey');
            const tlsCa = await getCertificateData(formData, 'tlsca');

            if (tlsCertificate) hostData.tls_cert = tlsCertificate;
            if (tlsKey) hostData.tls_key = tlsKey;
            if (tlsCa) hostData.tls_ca = tlsCa;

            const isEditing = window.editingHost !== null;
            const url = isEditing ? `${API_BASE}/api/hosts/${window.editingHost.id}` : `${API_BASE}/api/hosts`;
            const method = isEditing ? 'PUT' : 'POST';

            try {
                const response = await fetch(url, {
                    method: method,
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(hostData)
                });
                
                if (response.ok) {
                    const updatedHost = await response.json();

                    if (isEditing) {
                        showToast('‚úÖ Host updated successfully!');
                    } else {
                        showToast('‚úÖ Host added successfully!');
                    }

                    // Refresh hosts and containers from server to ensure we have complete data
                    await fetchHosts();
                    await fetchContainers();

                    // Explicitly refresh the host list on the Host Management page
                    renderHosts();
                    renderHostsPage(); // Make sure the Host Management page is updated too
                    updateStats();
                    updateNavBadges();
                    closeModal('hostModal');
                    event.target.reset();
                    window.editingHost = null;
                } else {
                    const error = await response.text();
                    const action = isEditing ? 'update' : 'add';
                    showToast(`‚ùå Failed to ${action} host: ${error}`);
                }
            } catch (error) {
                const action = isEditing ? 'update' : 'add';
                console.error(`Error ${action}ing host:`, error);
                showToast(`‚ùå Failed to ${action} host`);
            }
        }

        async function createAlertRule(event) {
            event.preventDefault();

            const states = [];
            const channels = [];
            let containerPattern = '';
            let hostId = null;
            let containerHostPairs = [];

            // Determine container selection
            // Check if "all containers" is selected
            if (document.getElementById('selectAllContainers').checked) {
                containerPattern = '.*';
                hostId = null;
                // Don't use container+host pairs for "all containers"
            } else {
                // Get selected containers with their host IDs
                document.querySelectorAll('#containerSelectionCheckboxes input[type="checkbox"]:checked').forEach(cb => {
                    if (cb.dataset.hostId && cb.value) {
                        containerHostPairs.push({
                            host_id: cb.dataset.hostId,
                            container_name: cb.value
                        });
                    }
                });

                if (containerHostPairs.length === 0) {
                    showToast('‚ùå Please select at least one container');
                    return;
                }

                // For the new system, we don't need to build patterns
                // The backend will handle the container+host pairs directly
                containerPattern = null; // Will be set to ".*" by backend as default
            }

            // Get selected events, states, and channels
            const events = [];
            event.target.querySelectorAll('input[type="checkbox"]:checked').forEach(cb => {
                if (cb.name === 'channels') {
                    channels.push(parseInt(cb.value));
                } else if (cb.dataset.event) {
                    events.push(cb.dataset.event);
                } else if (cb.dataset.state) {
                    states.push(cb.dataset.state);
                }
            });

            const ruleName = document.getElementById('alertRuleName').value;
            const cooldownMinutes = parseInt(document.getElementById('cooldownMinutes').value) || 15;

            // Validate that at least one trigger is selected
            if (events.length === 0 && states.length === 0) {
                showToast('‚ùå Please select at least one Docker event or state to monitor');
                return;
            }

            if (channels.length === 0) {
                showToast('‚ùå Please select at least one notification channel');
                return;
            }

            const ruleData = {
                name: ruleName,
                containers: containerHostPairs.length > 0 ? containerHostPairs : null,
                trigger_events: events.length > 0 ? events : [],
                trigger_states: states.length > 0 ? states : [],
                notification_channels: channels,
                cooldown_minutes: cooldownMinutes,
                enabled: true
            };

            const isEditing = editingAlertRule !== null;
            const url = isEditing ? `${API_BASE}/api/alerts/${editingAlertRule.id}` : `${API_BASE}/api/alerts`;
            const method = isEditing ? 'PUT' : 'POST';
            
            try {
                const response = await fetch(url, {
                    method: method,
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(ruleData)
                });
                
                if (response.ok) {
                    const rule = await response.json();

                    if (isEditing) {
                        showToast('‚úÖ Alert rule updated successfully!');
                        editingAlertRule = null;
                    } else {
                        showToast('‚úÖ Alert rule created successfully!');
                    }

                    // Fetch fresh data from server to ensure UI shows correct information
                    await fetchAlertRules();
                    renderAlertRules();
                    updateStats();
                    updateNavBadges();
                    closeModal('alertRuleModal');
                } else {
                    const errorData = await response.json().catch(() => ({ detail: 'Unknown error' }));
                    console.error(`Alert ${isEditing ? 'update' : 'creation'} failed:`, errorData);
                    const errorMessage = typeof errorData.detail === 'string'
                        ? errorData.detail
                        : JSON.stringify(errorData.detail) || response.statusText;
                    showToast(`‚ùå Failed to ${isEditing ? 'update' : 'create'} alert: ${errorMessage}`);
                }
            } catch (error) {
                console.error(`Error ${editingAlertRule ? 'updating' : 'creating'} alert rule:`, error);
                showToast(`‚ùå Failed to ${editingAlertRule ? 'update' : 'create'} alert rule`);
            }
        }

        async function saveNotificationSettings(event) {
            event.preventDefault();

            try {
                // Get form values
                const telegramToken = document.querySelector('#notificationModal .form-input[placeholder*="Telegram bot token"]').value;
                const telegramChatId = document.querySelector('#notificationModal .form-input[placeholder*="chat ID"]').value;
                const discordWebhook = document.querySelector('#notificationModal .form-input[placeholder*="Discord webhook"]').value;
                const pushoverToken = document.querySelector('#notificationModal .form-input[placeholder*="Pushover app token"]').value;
                const pushoverUserKey = document.querySelector('#notificationModal .form-input[placeholder*="user key"]').value;

                // Get existing channels to update or create
                const response = await fetch(`${API_BASE}/api/notifications/channels`, {
                    credentials: 'include'
                });
                const existingChannels = await response.json();

                const promises = [];

                // Handle Telegram
                if (telegramToken && telegramChatId) {
                    const telegramChannel = existingChannels.find(ch => ch.type === 'telegram');
                    const telegramData = {
                        name: 'Telegram',
                        type: 'telegram',
                        config: { bot_token: telegramToken, chat_id: telegramChatId },
                        enabled: true
                    };

                    if (telegramChannel) {
                        promises.push(fetch(`${API_BASE}/api/notifications/channels/${telegramChannel.id}`, {
                            method: 'PUT',
                            credentials: 'include',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                name: telegramData.name,
                                config: telegramData.config,
                                enabled: telegramData.enabled
                            })
                        }));
                    } else {
                        promises.push(fetch(`${API_BASE}/api/notifications/channels`, {
                            method: 'POST',
                            credentials: 'include',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(telegramData)
                        }));
                    }
                }

                // Handle Discord
                if (discordWebhook) {
                    const discordChannel = existingChannels.find(ch => ch.type === 'discord');
                    const discordData = {
                        name: 'Discord',
                        type: 'discord',
                        config: { webhook_url: discordWebhook },
                        enabled: true
                    };

                    if (discordChannel) {
                        promises.push(fetch(`${API_BASE}/api/notifications/channels/${discordChannel.id}`, {
                            method: 'PUT',
                            credentials: 'include',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                name: discordData.name,
                                config: discordData.config,
                                enabled: discordData.enabled
                            })
                        }));
                    } else {
                        promises.push(fetch(`${API_BASE}/api/notifications/channels`, {
                            method: 'POST',
                            credentials: 'include',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(discordData)
                        }));
                    }
                }

                // Handle Pushover
                if (pushoverToken && pushoverUserKey) {
                    const pushoverChannel = existingChannels.find(ch => ch.type === 'pushover');
                    const pushoverData = {
                        name: 'Pushover',
                        type: 'pushover',
                        config: { app_token: pushoverToken, user_key: pushoverUserKey },
                        enabled: true
                    };

                    if (pushoverChannel) {
                        promises.push(fetch(`${API_BASE}/api/notifications/channels/${pushoverChannel.id}`, {
                            method: 'PUT',
                            credentials: 'include',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                name: pushoverData.name,
                                config: pushoverData.config,
                                enabled: pushoverData.enabled
                            })
                        }));
                    } else {
                        promises.push(fetch(`${API_BASE}/api/notifications/channels`, {
                            method: 'POST',
                            credentials: 'include',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(pushoverData)
                        }));
                    }
                }

                // Wait for all requests to complete and check for errors
                const responses = await Promise.all(promises);

                // Check if any request failed
                for (const response of responses) {
                    if (!response.ok) {
                        const errorData = await response.json().catch(() => ({ detail: 'Unknown error' }));
                        const errorMessage = typeof errorData.detail === 'string'
                            ? errorData.detail
                            : JSON.stringify(errorData.detail) || response.statusText;
                        throw new Error(`API Error: ${errorMessage}`);
                    }
                }

                showToast('‚úÖ Notification settings saved!');
                closeModal('notificationModal');

                // Refresh notification channels for alert creation
                await populateNotificationChannels();

            } catch (error) {
                console.error('Error saving notification settings:', error);
                showToast(`‚ùå Failed to save notification settings: ${error.message}`);
            }
        }

        async function saveGlobalSettings() {
            globalSettings.max_retries = parseInt(document.getElementById('maxRetries').value);
            globalSettings.retry_delay = parseInt(document.getElementById('retryDelay').value);
            globalSettings.polling_interval = parseInt(document.getElementById('pollingInterval').value);
            globalSettings.connection_timeout = parseInt(document.getElementById('connectionTimeout').value);
            globalSettings.default_auto_restart = document.getElementById('defaultAutoRestart').classList.contains('active');
            
            try {
                const response = await fetch(`${API_BASE}/api/settings`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(globalSettings)
                });
                
                if (response.ok) {
                    showToast('‚úÖ Settings saved successfully!');
                    closeModal('globalSettingsModal');
                }
            } catch (error) {
                console.error('Error saving settings:', error);
                showToast('‚ùå Failed to save settings');
            }
        }

        async function deleteAlertRule(ruleId) {
            const rule = alertRules.find(r => r.id === ruleId);
            const ruleName = rule ? rule.name : 'Unknown Rule';

            const message = `Are you sure you want to delete the alert rule <strong>"${ruleName}"</strong>?<br><br>
                This will permanently remove the alert rule and you will no longer receive notifications for this container.<br><br>
                <strong>This action cannot be undone.</strong>`;

            showConfirmation('Delete Alert Rule', message, 'Delete Rule', async () => {
                try {
                    const response = await fetch(`${API_BASE}/api/alerts/${ruleId}`, {
                        method: 'DELETE'
                    });

                    if (response.ok) {
                        showToast('Alert rule deleted');
                        // Fetch fresh data from server to ensure UI is up to date
                        await fetchAlertRules();
                        renderAlertRules();
                        updateStats();
                        updateNavBadges();
                    }
                } catch (error) {
                    console.error('Error deleting alert rule:', error);
                    showToast('‚ùå Failed to delete alert rule');
                }
            });
        }

        async function deleteHost(hostId) {
            const host = hosts.find(h => h.id === hostId);
            const hostName = host ? host.name : 'Unknown Host';

            const message = `Are you sure you want to delete the host <strong>"${hostName}"</strong>?<br><br>
                This will:<br>
                ‚Ä¢ Remove the host and all its containers<br>
                ‚Ä¢ Delete any associated alert rules<br>
                ‚Ä¢ Stop all monitoring for this host<br><br>
                <strong>This action cannot be undone.</strong>`;

            showConfirmation('Delete Host', message, 'Delete Host', async () => {
                try {
                    const response = await fetch(`${API_BASE}/api/hosts/${hostId}`, {
                        method: 'DELETE'
                    });

                    if (response.ok) {
                        showToast('Host removed');
                        // Fetch fresh data from server
                        await fetchHosts();
                        await fetchContainers();
                        await fetchAlertRules();
                        renderHostsPage();
                        renderHosts();
                        updateStats();
                        updateNavBadges();
                    }
                } catch (error) {
                    console.error('Error deleting host:', error);
                    showToast('‚ùå Failed to delete host');
                }
            });
        }

        function editHost(hostId) {
            // Find the host to edit
            const host = hosts.find(h => h.id === hostId);
            if (!host) {
                showToast('‚ùå Host not found');
                return;
            }

            // Populate the form with existing host data
            document.querySelector('input[name="hostname"]').value = host.name;
            document.querySelector('input[name="hosturl"]').value = host.url;

            // Set up the modal for editing
            const modalTitle = document.querySelector('#hostModal .modal-title');
            const submitButton = document.querySelector('#hostModal button[type="submit"]');

            modalTitle.textContent = 'Edit Docker Host';
            submitButton.textContent = 'Update Host';

            // Store the host being edited
            window.editingHost = host;

            // Check security and show certificate fields if needed
            checkHostSecurity(host.url);

            // Show the modal
            document.getElementById('hostModal').classList.add('active');
        }

        async function refreshAll() {
            showToast('üîÑ Refreshing...');
            await Promise.all([
                fetchHosts(),
                fetchContainers(),
                fetchAlertRules()
            ]);
            renderHosts();
        }

        function showContainerDetails(containerId, preserveTab = null) {
            const container = containers.find(c => c.short_id === containerId);
            if (container) {
                // Only reset logs if we're switching to a different container
                if (!window.currentContainer || window.currentContainer.short_id !== container.short_id) {
                    // Stop any existing log polling when switching containers
                    stopAutoRefresh();

                    // Clear logs from previous container
                    const logsDiv = document.getElementById('container-logs');
                    if (logsDiv) {
                        logsDiv.innerHTML = '<div style="color: var(--text-tertiary);">Loading logs...</div>';
                    }
                    // Reset log state and filter
                    lastLogTimestamp = null;
                    accumulatedLogs = [];
                    const filterInput = document.getElementById('logSearchFilter');
                    if (filterInput) {
                        filterInput.value = '';
                    }
                    const matchCount = document.getElementById('logMatchCount');
                    if (matchCount) {
                        matchCount.textContent = '';
                    }
                }

                // Store current container info globally for modal functions
                window.currentContainer = container;

                // Check if there's an alert rule for this container on this specific host
                const hasAlert = alertRules.some(rule => {
                    // Check new container+host pairs format first
                    if (rule.containers && rule.containers.length > 0) {
                        return rule.containers.some(c =>
                            c.container_name === container.name && c.host_id === container.host_id
                        );
                    }
                    return false;
                });
                
                // Populate container details
                const detailsHtml = `
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-bottom: 20px;">
                        <div>
                            <strong>Name:</strong> ${container.name}<br>
                            <strong>ID:</strong> ${container.short_id}<br>
                            <strong>Image:</strong> ${container.image}<br>
                        </div>
                        <div>
                            <strong>State:</strong> <span class="${getStateClass(container.state)}">${container.state}</span><br>
                            <strong>Host:</strong> ${container.host_name}<br>
                            <strong>Created:</strong> ${new Date(container.created).toLocaleString()}<br>
                        </div>
                    </div>
                    <div class="container-actions" style="display: flex; gap: 10px; flex-wrap: wrap;" id="container-actions-${container.short_id}">
                        ${container.state === 'running' ? `
                            <button class="btn btn-danger" id="container-state-btn-${container.short_id}" onclick="stopContainer('${container.host_id}', '${container.id}')">
                                ‚èπÔ∏è Stop Container
                            </button>
                        ` : `
                            <button class="btn btn-primary" id="container-state-btn-${container.short_id}" onclick="startContainer('${container.host_id}', '${container.id}')">
                                ‚ñ∂Ô∏è Start Container
                            </button>
                        `}
                        <button class="btn btn-secondary" onclick="restartContainer('${container.host_id}', '${container.id}')">
                            üîÑ Restart Container
                        </button>
                        <button class="btn btn-secondary" onclick="createAlertForContainer('${container.id}')">
                            ‚ö° ${hasAlert ? 'Edit Alert' : 'Create Alert'}
                        </button>
                        <div class="auto-restart-toggle ${container.auto_restart ? 'enabled' : ''}"
                             onclick="toggleAutoRestart('${container.host_id}', '${container.id}', event)">
                            <span>üîÑ Auto-restart: ${container.auto_restart ? 'ON' : 'OFF'}</span>
                        </div>
                    </div>
                `;
                
                document.getElementById('container-info-content').innerHTML = detailsHtml;
                
                // Show modal
                const modal = document.getElementById('containerModal');
                modal.classList.add('active');

                // Load saved preferences or reset modal position
                const modalContent = modal.querySelector('.modal-content');
                if (modalContent) {
                    const savedPrefs = loadModalPreferences();
                    if (!savedPrefs) {
                        // No saved preferences, use defaults
                        modalContent.style.width = '900px';
                        modalContent.style.height = '600px';
                        modalContent.style.transform = 'translate(0, 0)';
                    }
                }

                // Make modal draggable
                makeModalDraggable('containerModal');

                // Add resize observer to adjust logs height and save preferences when modal is resized
                const resizeObserver = new ResizeObserver(entries => {
                    for (let entry of entries) {
                        if (entry.target.classList.contains('modal-content')) {
                            adjustLogsHeight();
                            // Save size after resize (debounced)
                            clearTimeout(window.resizeSaveTimeout);
                            window.resizeSaveTimeout = setTimeout(saveModalPreferences, 500);
                        }
                    }
                });
                resizeObserver.observe(modalContent);

                // Show the appropriate tab
                if (preserveTab) {
                    // Preserve the current tab selection
                    showTab(preserveTab);
                } else {
                    // Show info tab by default for new modal opens
                    showTab('info');
                }
            }
        }

        // Container Modal Functions
        function showTab(tab) {
            // Hide all tabs
            document.querySelectorAll('.tab-content').forEach(content => {
                content.style.display = 'none';
            });

            // Remove active class from all tab buttons
            document.querySelectorAll('[id^="tab-"]').forEach(btn => {
                btn.classList.remove('btn-primary');
                btn.classList.add('btn-secondary');
            });

            // Show selected tab
            document.getElementById(`${tab}-tab`).style.display = 'block';
            document.getElementById(`tab-${tab}`).classList.remove('btn-secondary');
            document.getElementById(`tab-${tab}`).classList.add('btn-primary');

            // Adjust logs height when switching to logs tab
            if (tab === 'logs') {
                // Check for saved logs height preference
                const saved = localStorage.getItem('containerModalPrefs');
                if (saved) {
                    try {
                        const prefs = JSON.parse(saved);
                        const logsDiv = document.getElementById('container-logs');
                        if (prefs.logsHeight && logsDiv) {
                            logsDiv.style.height = prefs.logsHeight;
                        } else {
                            adjustLogsHeight();
                        }
                    } catch (e) {
                        adjustLogsHeight();
                    }
                } else {
                    adjustLogsHeight();
                }
            }

            // Auto-fetch logs when logs tab is opened
            if (tab === 'logs' && window.currentContainer) {
                fetchContainerLogs();
                // Start auto-refresh if checkbox is checked
                const autoRefresh = document.getElementById('autoRefreshLogs');
                if (autoRefresh && autoRefresh.checked && !logPollInterval) {
                    startAutoRefresh();
                }

                // Add keyboard shortcut for filter (Ctrl/Cmd + F)
                if (!window.logFilterKeyHandler) {
                    window.logFilterKeyHandler = function(e) {
                        const logsTabVisible = document.getElementById('logs-tab').style.display !== 'none';
                        const modalActive = document.getElementById('containerModal').classList.contains('active');

                        if (modalActive && logsTabVisible && (e.ctrlKey || e.metaKey) && e.key === 'f') {
                            e.preventDefault();
                            const filterInput = document.getElementById('logSearchFilter');
                            if (filterInput) {
                                filterInput.focus();
                                filterInput.select();
                            }
                        }
                    };
                    document.addEventListener('keydown', window.logFilterKeyHandler);
                }
            } else if (tab !== 'logs') {
                // Stop auto-refresh when leaving logs tab
                stopAutoRefresh();
            }
            
            // Clear log stream if switching away from logs
            if (tab !== 'logs' && window.logStreamWs) {
                window.logStreamWs.close();
                window.logStreamWs = null;
                document.getElementById('streamLogsBtn').textContent = 'Start Live Stream';
            }
        }

        async function fetchContainerLogs(incremental = false) {
            if (!window.currentContainer) return;

            const tailCount = document.getElementById('logTailCount').value || 100;
            const logsDiv = document.getElementById('container-logs');

            // Only show loading on first fetch
            if (!incremental || !accumulatedLogs.length) {
                logsDiv.innerHTML = '<div style="color: var(--text-secondary);">Loading logs...</div>';
                lastLogTimestamp = null;
                accumulatedLogs = [];
            }

            try {
                // Build URL with optional since parameter for incremental updates
                let url = `${API_BASE}/api/hosts/${window.currentContainer.host_id}/containers/${window.currentContainer.id}/logs?tail=${tailCount}`;
                if (incremental && lastLogTimestamp) {
                    url += `&since=${encodeURIComponent(lastLogTimestamp)}`;
                }

                // Increase timeout for large log fetches
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 30000); // 30 second timeout

                const response = await fetch(url, { signal: controller.signal });

                clearTimeout(timeoutId);

                if (response.ok) {
                    const data = await response.json();

                    // Update timestamp for next incremental fetch
                    if (data.last_timestamp) {
                        lastLogTimestamp = data.last_timestamp;
                    }

                    if (data.logs && Array.isArray(data.logs)) {
                        // Always replace logs for simplicity and to avoid duplicates
                        // Auto-refresh will just keep fetching the latest N logs
                        accumulatedLogs = data.logs.filter(line => line.trim());

                        updateLogDisplay();
                        // Auto-scroll to bottom only if no filter is active
                        const filterText = document.getElementById('logSearchFilter')?.value || '';
                        if (!filterText) {
                            logsDiv.scrollTop = logsDiv.scrollHeight;
                        }
                    } else {
                        logsDiv.innerHTML = '<div style="color: var(--text-tertiary);">No logs available</div>';
                    }
                } else {
                    logsDiv.innerHTML = '<div style="color: var(--danger);">Failed to fetch logs</div>';
                    stopAutoRefresh();
                }
            } catch (error) {
                console.error('Error fetching logs:', error);
                if (error.name === 'AbortError') {
                    logsDiv.innerHTML = '<div style="color: var(--danger);">Log fetch timeout - try reducing the log count</div>';
                } else {
                    logsDiv.innerHTML = '<div style="color: var(--danger);">Error loading logs</div>';
                }
                stopAutoRefresh();
            }
        }

        // Portainer-style HTTP polling for logs (more reliable than WebSocket)
        let logPollInterval = null;
        let lastLogTimestamp = null;
        let accumulatedLogs = [];

        function toggleAutoRefresh() {
            const checkbox = document.getElementById('autoRefreshLogs');
            if (checkbox.checked) {
                startAutoRefresh();
            } else {
                stopAutoRefresh();
            }
        }

        function startAutoRefresh() {
            if (logPollInterval || !window.currentContainer) return;

            // Poll every 2 seconds
            logPollInterval = setInterval(() => {
                // Don't use incremental updates - just refresh with the same tail count
                // This avoids duplicate/accumulation issues
                fetchContainerLogs(false);
            }, 2000);
        }

        function stopAutoRefresh() {
            if (logPollInterval) {
                clearInterval(logPollInterval);
                logPollInterval = null;
            }
        }

        function updateLogDisplay() {
            const logsDiv = document.getElementById('container-logs');
            if (!logsDiv || !accumulatedLogs.length) {
                const matchCount = document.getElementById('logMatchCount');
                if (matchCount) matchCount.textContent = '';
                return;
            }

            const showTimestamps = document.getElementById('showTimestamps').checked;
            const filterText = document.getElementById('logSearchFilter')?.value.toLowerCase() || '';
            let displayLogs = accumulatedLogs;

            // Remove timestamps if needed
            if (!showTimestamps) {
                displayLogs = displayLogs.map(line => {
                    // Match various timestamp formats at the beginning of the line
                    return line.replace(/^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(?:\.\d+)?(?:Z|[+-]\d{2}:\d{2})?\s*/, '');
                });
            }

            // Apply filter
            let filteredLogs = displayLogs;
            let matchCount = 0;
            if (filterText) {
                filteredLogs = displayLogs.filter(line => {
                    const matches = line.toLowerCase().includes(filterText);
                    if (matches) matchCount++;
                    return matches;
                });
            } else {
                matchCount = displayLogs.length;
            }

            // Update match count - only show when filtering
            const matchCountElem = document.getElementById('logMatchCount');
            if (matchCountElem) {
                if (filterText) {
                    matchCountElem.textContent = `${matchCount} matches`;
                } else {
                    matchCountElem.textContent = ''; // Don't show count when not filtering
                }
            }

            // Display logs with optional highlighting
            if (filterText && filteredLogs.length > 0) {
                // Escape special regex characters in search text
                const escapedFilter = filterText.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
                const regex = new RegExp(`(${escapedFilter})`, 'gi');

                const highlightedLogs = filteredLogs.map(line => {
                    // HTML escape the line first
                    const escaped = line.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
                    // Then add highlighting
                    return escaped.replace(regex, '<mark style="background: #ffeb3b; color: #000; padding: 2px;">$1</mark>');
                });
                logsDiv.innerHTML = highlightedLogs.join('\n') || '<div style="color: var(--text-tertiary);">No matching logs found</div>';
            } else if (filterText && filteredLogs.length === 0) {
                logsDiv.innerHTML = '<div style="color: var(--text-tertiary);">No logs match the filter</div>';
            } else {
                // HTML escape for safety
                const escapedLogs = filteredLogs.map(line =>
                    line.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;')
                );
                logsDiv.innerHTML = escapedLogs.join('\n') || '<div style="color: var(--text-tertiary);">No logs available</div>';
            }

            // Keep scroll at bottom if we were already at bottom
            if (logsDiv.scrollHeight - logsDiv.scrollTop <= logsDiv.clientHeight + 50) {
                logsDiv.scrollTop = logsDiv.scrollHeight;
            }
        }

        function clearLogFilter() {
            const filterInput = document.getElementById('logSearchFilter');
            if (filterInput) {
                filterInput.value = '';
                updateLogDisplay();
                filterInput.focus();
            }
        }

        function adjustLogsHeight() {
            const modal = document.querySelector('#containerModal .modal-content');
            const logsDiv = document.getElementById('container-logs');
            const logsTab = document.getElementById('logs-tab');

            if (modal && logsDiv && logsTab && logsTab.style.display !== 'none') {
                // Calculate available height for logs
                const modalHeight = modal.offsetHeight;
                const headerHeight = modal.querySelector('.modal-header').offsetHeight || 60;
                const tabsHeight = 120; // Approximate height of tabs and controls
                const padding = 120; // Extra padding

                const availableHeight = modalHeight - headerHeight - tabsHeight - padding;
                if (availableHeight > 200) {
                    logsDiv.style.height = `${Math.min(availableHeight, 600)}px`;
                }
            }
        }

        // Old toggleLogStream function removed - replaced with auto-refresh checkbox

        // Container exec functionality removed for security reasons
        // Users should use direct SSH, Docker CLI, or other appropriate tools for container access

        async function restartContainer(hostId, containerId) {
            try {
                const response = await fetch(`${API_BASE}/api/hosts/${hostId}/containers/${containerId}/restart`, {
                    method: 'POST'
                });
                
                if (response.ok) {
                    showToast('üîÑ Container restarting...');
                } else {
                    showToast('‚ùå Failed to restart container');
                }
            } catch (error) {
                console.error('Error restarting container:', error);
                showToast('‚ùå Failed to restart container');
            }
        }

        async function startContainer(hostId, containerId) {
            // Find container to update UI immediately
            const container = containers.find(c => c.id === containerId);
            if (container) {
                // Update button immediately to show transitional state
                const btn = document.getElementById(`container-state-btn-${container.short_id}`);
                if (btn) {
                    btn.innerHTML = 'üîÑ Starting...';
                    btn.className = 'btn';
                    btn.style.backgroundColor = '#90ee90';
                    btn.style.color = '#333';
                    btn.disabled = true;
                }
            }

            try {
                const response = await fetch(`${API_BASE}/api/hosts/${hostId}/containers/${containerId}/start`, {
                    method: 'POST'
                });

                if (response.ok) {
                    showToast('‚ñ∂Ô∏è Container starting...');
                } else {
                    showToast('‚ùå Failed to start container');
                    // Revert button state on failure
                    if (container) {
                        const btn = document.getElementById(`container-state-btn-${container.short_id}`);
                        if (btn) {
                            btn.innerHTML = '‚ñ∂Ô∏è Start Container';
                            btn.className = 'btn btn-primary';
                            btn.style.backgroundColor = '';
                            btn.style.color = '';
                            btn.disabled = false;
                        }
                    }
                }
            } catch (error) {
                console.error('Error starting container:', error);
                showToast('‚ùå Failed to start container');
                // Revert button state on error
                if (container) {
                    const btn = document.getElementById(`container-state-btn-${container.short_id}`);
                    if (btn) {
                        btn.innerHTML = '‚ñ∂Ô∏è Start Container';
                        btn.className = 'btn btn-primary';
                        btn.style.backgroundColor = '';
                        btn.style.color = '';
                        btn.disabled = false;
                    }
                }
            }
        }

        async function stopContainer(hostId, containerId) {
            // Find container to update UI immediately
            const container = containers.find(c => c.id === containerId);
            if (container) {
                // Update button immediately to show transitional state
                const btn = document.getElementById(`container-state-btn-${container.short_id}`);
                if (btn) {
                    btn.innerHTML = 'üîÑ Stopping...';
                    btn.className = 'btn';
                    btn.style.backgroundColor = '#ffa500';
                    btn.style.color = '#fff';
                    btn.disabled = true;
                }
            }

            try {
                const response = await fetch(`${API_BASE}/api/hosts/${hostId}/containers/${containerId}/stop`, {
                    method: 'POST'
                });

                if (response.ok) {
                    showToast('‚èπÔ∏è Container stopping...');
                } else {
                    showToast('‚ùå Failed to stop container');
                    // Revert button state on failure
                    if (container) {
                        const btn = document.getElementById(`container-state-btn-${container.short_id}`);
                        if (btn) {
                            btn.innerHTML = '‚èπÔ∏è Stop Container';
                            btn.className = 'btn btn-danger';
                            btn.style.backgroundColor = '';
                            btn.style.color = '';
                            btn.disabled = false;
                        }
                    }
                }
            } catch (error) {
                console.error('Error stopping container:', error);
                showToast('‚ùå Failed to stop container');
                // Revert button state on error
                if (container) {
                    const btn = document.getElementById(`container-state-btn-${container.short_id}`);
                    if (btn) {
                        btn.innerHTML = '‚èπÔ∏è Stop Container';
                        btn.className = 'btn btn-danger';
                        btn.style.backgroundColor = '';
                        btn.style.color = '';
                        btn.disabled = false;
                    }
                }
            }
        }

        function showToast(message) {
            const toast = document.getElementById('toast');
            toast.textContent = message;
            toast.classList.add('show');
            setTimeout(() => {
                toast.classList.remove('show');
            }, 3000);
        }

        // GridStack Dashboard
        let grid = null;
        let dashboardLocked = false;

        function initDashboard() {
            console.log('initDashboard called');

            // Check if dashboard grid container exists
            const dashboardGridElement = document.getElementById('dashboard-grid');
            if (!dashboardGridElement) {
                console.error('Dashboard grid element not found!');
                return;
            }

            // Initialize GridStack with better flexibility
            try {
                grid = GridStack.init({
                    column: 12,      // Keep standard 12 columns
                    cellHeight: 40,  // Smaller cells for better control
                    margin: 4,       // Tighter margins
                    animate: true,
                    float: true,
                    draggable: {
                        handle: '.widget-header'
                    },
                    resizable: {
                        handles: 'e, se, s, sw, w'
                    }
                }, '#dashboard-grid');

                console.log('GridStack initialized successfully');

                // Load saved layout or use default
                const savedLayout = localStorage.getItem('dashboardLayout');
                if (savedLayout) {
                    console.log('Loading saved dashboard layout');
                    loadDashboardLayout(JSON.parse(savedLayout));
                } else {
                    console.log('Creating default dashboard layout');
                    createDefaultDashboard();
                }

                // Save layout on change
                grid.on('change', saveDashboardLayout);

                // Render widgets with current data
                renderDashboardWidgets();
                console.log('Dashboard initialization completed');
            } catch (error) {
                console.error('Failed to initialize dashboard:', error);
            }
        }

        function createDefaultDashboard() {
            // Stats Widget - taller to ensure content fits
            const statsWidget = createWidget('stats', 'Statistics', 'üìä', {
                x: 0, y: 0, w: 12, h: 4,
                minW: 4, minH: 4, maxH: 6
            });

            // Create individual widgets for each host
            createHostWidgets();

            // Use setTimeout to ensure widgets are fully created before rendering
            setTimeout(() => renderDashboardWidgets(), 50);
        }

        function createHostWidgets() {
            // Remove existing host widgets first
            const existingHostWidgets = grid.getGridItems().filter(item =>
                item.getAttribute('data-widget-id').startsWith('host-')
            );
            existingHostWidgets.forEach(widget => grid.removeWidget(widget));

            // Create a widget for each host with dynamic sizing and smart positioning
            let currentY = 5; // Start below stats widget
            let leftColumnY = 5;
            let rightColumnY = 5;

            hosts.forEach((host, index) => {
                const widgetId = `host-${host.id}`;
                const hostContainers = containers.filter(c => c.host_id === host.id);

                // Calculate height based on container count
                const containerRows = Math.max(1, hostContainers.length);
                const headerHeight = 4; // Widget header + host header
                const containerHeight = 2.2; // Each container needs more space for proper display
                const dynamicHeight = headerHeight + containerRows * containerHeight + 0.5; // Add padding for bottom border
                const widgetHeight = Math.max(6, Math.ceil(dynamicHeight)); // Minimum height of 6


                // Smart column placement - use the shorter column
                let x, y;
                if (leftColumnY <= rightColumnY) {
                    // Place in left column
                    x = 0;
                    y = leftColumnY;
                    leftColumnY = y + widgetHeight + 1; // Add gap
                } else {
                    // Place in right column
                    x = 6;
                    y = rightColumnY;
                    rightColumnY = y + widgetHeight + 1; // Add gap
                }

                const widget = createWidget(widgetId, host.name, 'üñ•Ô∏è', {
                    x: x,
                    y: y,
                    w: 6,
                    h: widgetHeight,
                    minW: 3, minH: 3
                });
            });
        }

        function createWidget(id, title, icon, gridOptions) {
            const widgetHtml = `
                <div class="grid-stack-item" data-widget-id="${id}" gs-x="${gridOptions.x}" gs-y="${gridOptions.y}"
                     gs-w="${gridOptions.w}" gs-h="${gridOptions.h}"
                     gs-min-w="${gridOptions.minW || 2}" gs-min-h="${gridOptions.minH || 2}"
                     ${gridOptions.maxH ? `gs-max-h="${gridOptions.maxH}"` : ''}>
                    <div class="grid-stack-item-content">
                        <div class="widget-header">
                            <div class="widget-title">
                                <span>${icon}</span>
                                <span>${title}</span>
                            </div>
                            <div class="widget-actions">
                                <button class="widget-action lock-btn" onclick="toggleWidgetLock(this)" title="Lock widget">
                                    üîì
                                </button>
                                <button class="widget-action" onclick="removeWidget('${id}')" title="Remove widget">
                                    ‚úï
                                </button>
                            </div>
                        </div>
                        <div class="widget-body" id="widget-${id}">
                            <!-- Content will be rendered here -->
                        </div>
                    </div>
                </div>
            `;

            grid.addWidget(widgetHtml);
            return document.querySelector(`[data-widget-id="${id}"]`);
        }

        function renderDashboardWidgets() {
            console.log('Rendering dashboard widgets - hosts:', hosts.length, 'containers:', containers.length);

            // Update host widgets if hosts have changed
            if (grid) {
                createHostWidgets();
            }

            // Render stats widget - simplified layout without icons
            const statsWidget = document.getElementById('widget-stats');
            if (statsWidget) {
                statsWidget.innerHTML = `
                    <div class="stats-grid">
                        <div class="stat-card">
                            <div class="stat-label">Total Hosts</div>
                            <div class="stat-value">${hosts.length}</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-label">Total Containers</div>
                            <div class="stat-value">${containers.length}</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-label">Running</div>
                            <div class="stat-value">${containers.filter(c => c.state === 'running').length}</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-label">Alert Rules</div>
                            <div class="stat-value">${alertRules.length}</div>
                        </div>
                    </div>
                `;
            }

            // Render individual host widgets
            hosts.forEach(host => {
                const hostWidget = document.getElementById(`widget-host-${host.id}`);
                if (hostWidget) {
                    const hostContainers = containers.filter(c => c.host_id === host.id).sort((a, b) => a.name.localeCompare(b.name));
                    const maxContainersToShow = hostContainers.length; // Show all containers now that widgets are dynamically sized
                    const containersList = hostContainers.slice(0, maxContainersToShow).map(container => `
                        <div class="container-item">
                            <div class="container-info" onclick="showContainerDetails('${container.short_id}')">
                                <div class="container-icon container-${container.state}">
                                    ${getContainerIcon(container.state)}
                                </div>
                                <div class="container-details">
                                    <div class="container-name">${container.name}</div>
                                    <div class="container-id">${container.short_id}</div>
                                </div>
                            </div>
                            <div class="container-actions">
                                <div class="auto-restart-toggle ${container.auto_restart ? 'enabled' : ''}"
                                     onclick="event.stopPropagation()">
                                    <span>üîÑ</span>
                                    <div class="toggle-switch ${container.auto_restart ? 'active' : ''}"
                                         onclick="toggleAutoRestart('${container.host_id}', '${container.short_id}', event)"></div>
                                </div>
                                <span class="container-state ${getStateClass(container.state)}">
                                    ${container.state}
                                </span>
                            </div>
                        </div>
                    `).join('');

                    const moreCount = hostContainers.length > maxContainersToShow ? hostContainers.length - maxContainersToShow : 0;

                    hostWidget.innerHTML = `
                        <div class="host-card">
                            <div class="host-header">
                                <div class="host-name">
                                    <span>üñ•Ô∏è</span> ${host.name}
                                    <span class="host-status status-${host.status}">${host.status}</span>
                                </div>
                            </div>
                            <div class="container-list">
                                ${containersList || '<div style="padding: 12px; color: var(--text-tertiary); text-align: center;">No containers</div>'}
                                ${moreCount > 0 ? `<div style="padding: 8px 12px; font-size: 12px; color: var(--text-tertiary); text-align: center; border-top: 1px solid var(--border);">+${moreCount} more containers</div>` : ''}
                            </div>
                        </div>
                    `;
                }
            });
        }

        function toggleDashboardLock() {
            dashboardLocked = !dashboardLocked;
            grid.setStatic(dashboardLocked);

            const btn = document.getElementById('dashboardLockBtn');
            const icon = document.getElementById('lockBtnIcon');
            const text = document.getElementById('lockBtnText');

            if (dashboardLocked) {
                icon.textContent = 'üîí';
                text.textContent = 'Unlock Layout';
                document.querySelectorAll('.lock-btn').forEach(btn => {
                    btn.textContent = 'üîí';
                    btn.classList.add('locked');
                });
            } else {
                icon.textContent = 'üîì';
                text.textContent = 'Lock Layout';
                document.querySelectorAll('.lock-btn').forEach(btn => {
                    btn.textContent = 'üîì';
                    btn.classList.remove('locked');
                });
            }
        }

        function toggleWidgetLock(btn) {
            const widget = btn.closest('.grid-stack-item');
            const isLocked = widget.classList.contains('gs-locked');

            if (isLocked) {
                grid.movable(widget, true);
                grid.resizable(widget, true);
                widget.classList.remove('gs-locked');
                btn.textContent = 'üîì';
                btn.classList.remove('locked');
            } else {
                grid.movable(widget, false);
                grid.resizable(widget, false);
                widget.classList.add('gs-locked');
                btn.textContent = 'üîí';
                btn.classList.add('locked');
            }
        }

        function removeWidget(id) {
            const widget = document.querySelector(`[data-widget-id="${id}"]`);
            if (widget) {
                grid.removeWidget(widget);
                saveDashboardLayout();
            }
        }

        function saveDashboardLayout() {
            const items = grid.getGridItems();
            const layout = items.map(item => ({
                id: item.getAttribute('data-widget-id'),
                x: parseInt(item.getAttribute('gs-x')),
                y: parseInt(item.getAttribute('gs-y')),
                w: parseInt(item.getAttribute('gs-w')),
                h: parseInt(item.getAttribute('gs-h'))
            }));
            localStorage.setItem('dashboardLayout', JSON.stringify(layout));
        }

        function loadDashboardLayout(layout) {
            layout.forEach(item => {
                const widgetConfig = getWidgetConfig(item.id);
                if (widgetConfig) {
                    createWidget(widgetConfig.id, widgetConfig.title, widgetConfig.icon, {
                        x: item.x,
                        y: item.y,
                        w: item.w,
                        h: item.h,
                        minW: widgetConfig.minW,
                        minH: widgetConfig.minH,
                        maxH: widgetConfig.maxH
                    });
                }
            });
            // Use setTimeout to ensure widgets are fully created before rendering
            setTimeout(() => renderDashboardWidgets(), 50);
        }

        function getWidgetConfig(id) {
            const configs = {
                'stats': { id: 'stats', title: 'Statistics', icon: 'üìä', minW: 4, minH: 4, maxH: 6 }
            };

            // Dynamic configs for host widgets
            if (id.startsWith('host-')) {
                const hostId = id.replace('host-', '');
                const host = hosts.find(h => h.id === hostId);
                if (host) {
                    return { id: id, title: host.name, icon: 'üñ•Ô∏è', minW: 3, minH: 3 };
                }
            }

            return configs[id];
        }

        function resetDashboardLayout() {
            localStorage.removeItem('dashboardLayout');
            grid.removeAll();
            createDefaultDashboard();
            showToast('Dashboard layout reset to default');
        }


        // Initialize on load
        window.addEventListener('DOMContentLoaded', async () => {
            try {
                await init();
                // Check if password change is required
                checkPasswordChangeRequired();
                // Get current user info
                await getCurrentUser();
                // Dashboard will be initialized when WebSocket data arrives
                // or when user navigates to dashboard page
            } catch (error) {
                console.error('Failed to initialize application:', error);
                // Don't show error toast - WebSocket will handle data delivery
            }
        });
    </script>

    <!-- Logout Button -->
    <button class="logout-button" onclick="logout()" title="Logout">
        <span>üö™</span>
        <span>Logout</span>
    </button>

    <!-- GridStack.js Scripts -->
    <script src="https://cdn.jsdelivr.net/npm/gridstack@10.0.1/dist/gridstack-all.js"></script>
</body>
</html>